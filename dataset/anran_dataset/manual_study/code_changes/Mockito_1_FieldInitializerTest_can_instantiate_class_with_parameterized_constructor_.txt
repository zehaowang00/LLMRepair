commit d26f5db9023b6b7cd331017551ea4353fff0ef91
Author: Brice Dutheil <brice.dutheil@gmail.com>
Date:   Tue Jun 2 08:06:50 2015

    Removes all CRLF line ending created by misconfigured Windows IDE

diff --git a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
--- a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
+++ b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
@@ -5,203 +158,9 @@
-package org.mockito.internal.util.reflection;
-
-import org.junit.Test;
-import org.mockito.InjectMocks;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;
-
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-
-import static org.junit.Assert.*;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.mock;
-
-
-
-public class FieldInitializerTest {
-
-    private StaticClass alreadyInstantiated = new StaticClass();
-    private StaticClass noConstructor;
-    private StaticClassWithDefaultConstructor defaultConstructor;
-    private StaticClassWithPrivateDefaultConstructor privateDefaultConstructor;
-    private StaticClassWithoutDefaultConstructor noDefaultConstructor;
-    private StaticClassThrowingExceptionDefaultConstructor throwingExDefaultConstructor;
-    private AbstractStaticClass abstractType;
-    private Interface interfaceType;
-    private InnerClassType innerClassType;
-    private AbstractStaticClass instantiatedAbstractType = new ConcreteStaticClass();
-    private Interface instantiatedInterfaceType =  new ConcreteStaticClass();
-    private InnerClassType instantiatedInnerClassType = new InnerClassType();
-
-    @Test
-    public void should_keep_same_instance_if_field_initialized() throws Exception {
-        final StaticClass backupInstance = alreadyInstantiated;
-        FieldInitializer fieldInitializer = new FieldInitializer(this, field("alreadyInstantiated"));
-        FieldInitializationReport report = fieldInitializer.initialize();
-
-        assertSame(backupInstance, report.fieldInstance());
-        assertFalse(report.fieldWasInitialized());
-        assertFalse(report.fieldWasInitializedUsingContructorArgs());
-    }
-
-    @Test
-    public void should_instantiate_field_when_type_has_no_constructor() throws Exception {
-        FieldInitializer fieldInitializer = new FieldInitializer(this, field("noConstructor"));
-        FieldInitializationReport report = fieldInitializer.initialize();
-
-        assertNotNull(report.fieldInstance());
-        assertTrue(report.fieldWasInitialized());
-        assertFalse(report.fieldWasInitializedUsingContructorArgs());
-    }
-
-    @Test
-    public void should_instantiate_field_with_default_constructor() throws Exception {
-        FieldInitializer fieldInitializer = new FieldInitializer(this, field("defaultConstructor"));
-        FieldInitializationReport report = fieldInitializer.initialize();
-
-        assertNotNull(report.fieldInstance());
-        assertTrue(report.fieldWasInitialized());
-        assertFalse(report.fieldWasInitializedUsingContructorArgs());
-    }
-
-    @Test
-    public void should_instantiate_field_with_private_default_constructor() throws Exception {
-        FieldInitializer fieldInitializer = new FieldInitializer(this, field("privateDefaultConstructor"));
-        FieldInitializationReport report = fieldInitializer.initialize();
-
-        assertNotNull(report.fieldInstance());
-        assertTrue(report.fieldWasInitialized());
-        assertFalse(report.fieldWasInitializedUsingContructorArgs());
-    }
-
-    @Test(expected = MockitoException.class)
-    public void should_fail_to_instantiate_field_if_no_default_constructor() throws Exception {
-        FieldInitializer fieldInitializer = new FieldInitializer(this, field("noDefaultConstructor"));
-        fieldInitializer.initialize();
-    }
-
-    @Test
-    public void should_fail_to_instantiate_field_if_default_constructor_throws_exception() throws Exception {
-        FieldInitializer fieldInitializer = new FieldInitializer(this, field("throwingExDefaultConstructor"));
-        try {
-            fieldInitializer.initialize();
-            fail();
-        } catch (MockitoException e) {
-            InvocationTargetException ite = (InvocationTargetException) e.getCause();
-            assertTrue(ite.getTargetException() instanceof NullPointerException);
-            assertEquals("business logic failed", ite.getTargetException().getMessage());
-        }
-    }
-
-    @Test(expected = MockitoException.class)
-    public void should_fail_for_abstract_field() throws Exception {
-        new FieldInitializer(this, field("abstractType"));
-    }
-
-    @Test
-    public void should_not_fail_if_abstract_field_is_instantiated() throws Exception {
-        new FieldInitializer(this, field("instantiatedAbstractType"));
-    }
-
-    @Test(expected = MockitoException.class)
-    public void should_fail_for_interface_field() throws Exception {
-        new FieldInitializer(this, field("interfaceType"));
-    }
-
-    @Test
-    public void should_not_fail_if_interface_field_is_instantiated() throws Exception {
-        new FieldInitializer(this, field("instantiatedInterfaceType"));
-    }
-
-    @Test(expected = MockitoException.class)
-    public void should_fail_for_local_type_field() throws Exception {
-        // when
-        class LocalType { }
-
-        class TheTestWithLocalType {
-            @InjectMocks LocalType field;
-        }
-
-        TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();
-
-        // when
-        new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));
-    }
-
-    @Test
-    public void should_not_fail_if_local_type_field_is_instantiated() throws Exception {
-        // when
-        class LocalType { }
-
-        class TheTestWithLocalType {
-            @InjectMocks LocalType field = new LocalType();
-        }
-
-        TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();
-
-        // when
-        new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));
-    }
-
-    @Test(expected = MockitoException.class)
-    public void should_fail_for_inner_class_field() throws Exception {
-        new FieldInitializer(this, field("innerClassType"));
-    }
-
-    @Test
-    public void should_not_fail_if_inner_class_field_is_instantiated() throws Exception {
-        new FieldInitializer(this, field("instantiatedInnerClassType"));
-    }
-
-    @Test
-    public void can_instantiate_class_with_parameterized_constructor() throws Exception {
-        ConstructorArgumentResolver resolver = given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class[].class)))
-                        .willReturn(new Object[]{null}).getMock();
-
-        new FieldInitializer(this, field("noDefaultConstructor"), resolver).initialize();
-
-        assertNotNull(noDefaultConstructor);
-    }
-
-    private Field field(String fieldName) throws NoSuchFieldException {
-        return this.getClass().getDeclaredField(fieldName);
-    }
-
-    static class StaticClass {
-    }
-
-    static class StaticClassWithDefaultConstructor {
-        StaticClassWithDefaultConstructor() { }
-    }
-
-    static class StaticClassWithPrivateDefaultConstructor {
-        private StaticClassWithPrivateDefaultConstructor() { }
-    }
-
-    static class StaticClassWithoutDefaultConstructor {
-        private StaticClassWithoutDefaultConstructor(String param) { }
-    }
-
-    static class StaticClassThrowingExceptionDefaultConstructor {
-        StaticClassThrowingExceptionDefaultConstructor() throws Exception {
-            throw new NullPointerException("business logic failed");
-        }
-    }
-    
-    static abstract class AbstractStaticClass {
-        public AbstractStaticClass() {}
-    }
-
-    interface Interface {
-
-    }
-
-    static class ConcreteStaticClass extends AbstractStaticClass implements Interface {
-    }
-
-    class InnerClassType {
-        InnerClassType() { }
-    }
-
-}
+    public void can_instantiate_class_with_parameterized_constructor() throws Exception {
+        ConstructorArgumentResolver resolver = given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class[].class)))
+                        .willReturn(new Object[]{null}).getMock();
+
+        new FieldInitializer(this, field("noDefaultConstructor"), resolver).initialize();
+
+        assertNotNull(noDefaultConstructor);
+    }
+

commit 5e3a9dcd5c4acbe5b87d8c458df7f8a925ebe1e6
Author: Kamil Szymanski <kamil.szymanski.dev@gmail.com>
Date:   Tue Feb 18 07:20:42 2014

    remove redundant static keyword
    
    inner interfaces are implicitly static

diff --git a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
--- a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
+++ b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
@@ -5,203 +5,203 @@
 package org.mockito.internal.util.reflection;
 
 import org.junit.Test;
 import org.mockito.InjectMocks;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 
 import static org.junit.Assert.*;
 import static org.mockito.BDDMockito.given;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.mock;
 
 
 
 public class FieldInitializerTest {
 
     private StaticClass alreadyInstantiated = new StaticClass();
     private StaticClass noConstructor;
     private StaticClassWithDefaultConstructor defaultConstructor;
     private StaticClassWithPrivateDefaultConstructor privateDefaultConstructor;
     private StaticClassWithoutDefaultConstructor noDefaultConstructor;
     private StaticClassThrowingExceptionDefaultConstructor throwingExDefaultConstructor;
     private AbstractStaticClass abstractType;
     private Interface interfaceType;
     private InnerClassType innerClassType;
     private AbstractStaticClass instantiatedAbstractType = new ConcreteStaticClass();
     private Interface instantiatedInterfaceType =  new ConcreteStaticClass();
     private InnerClassType instantiatedInnerClassType = new InnerClassType();
 
     @Test
     public void should_keep_same_instance_if_field_initialized() throws Exception {
         final StaticClass backupInstance = alreadyInstantiated;
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("alreadyInstantiated"));
         FieldInitializationReport report = fieldInitializer.initialize();
 
         assertSame(backupInstance, report.fieldInstance());
         assertFalse(report.fieldWasInitialized());
         assertFalse(report.fieldWasInitializedUsingContructorArgs());
     }
 
     @Test
     public void should_instantiate_field_when_type_has_no_constructor() throws Exception {
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("noConstructor"));
         FieldInitializationReport report = fieldInitializer.initialize();
 
         assertNotNull(report.fieldInstance());
         assertTrue(report.fieldWasInitialized());
         assertFalse(report.fieldWasInitializedUsingContructorArgs());
     }
 
     @Test
     public void should_instantiate_field_with_default_constructor() throws Exception {
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("defaultConstructor"));
         FieldInitializationReport report = fieldInitializer.initialize();
 
         assertNotNull(report.fieldInstance());
         assertTrue(report.fieldWasInitialized());
         assertFalse(report.fieldWasInitializedUsingContructorArgs());
     }
 
     @Test
     public void should_instantiate_field_with_private_default_constructor() throws Exception {
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("privateDefaultConstructor"));
         FieldInitializationReport report = fieldInitializer.initialize();
 
         assertNotNull(report.fieldInstance());
         assertTrue(report.fieldWasInitialized());
         assertFalse(report.fieldWasInitializedUsingContructorArgs());
     }
 
     @Test(expected = MockitoException.class)
     public void should_fail_to_instantiate_field_if_no_default_constructor() throws Exception {
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("noDefaultConstructor"));
         fieldInitializer.initialize();
     }
 
     @Test
     public void should_fail_to_instantiate_field_if_default_constructor_throws_exception() throws Exception {
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("throwingExDefaultConstructor"));
         try {
             fieldInitializer.initialize();
             fail();
         } catch (MockitoException e) {
             InvocationTargetException ite = (InvocationTargetException) e.getCause();
             assertTrue(ite.getTargetException() instanceof NullPointerException);
             assertEquals("business logic failed", ite.getTargetException().getMessage());
         }
     }
 
     @Test(expected = MockitoException.class)
     public void should_fail_for_abstract_field() throws Exception {
         new FieldInitializer(this, field("abstractType"));
     }
 
     @Test
     public void should_not_fail_if_abstract_field_is_instantiated() throws Exception {
         new FieldInitializer(this, field("instantiatedAbstractType"));
     }
 
     @Test(expected = MockitoException.class)
     public void should_fail_for_interface_field() throws Exception {
         new FieldInitializer(this, field("interfaceType"));
     }
 
     @Test
     public void should_not_fail_if_interface_field_is_instantiated() throws Exception {
         new FieldInitializer(this, field("instantiatedInterfaceType"));
     }
 
     @Test(expected = MockitoException.class)
     public void should_fail_for_local_type_field() throws Exception {
         // when
         class LocalType { }
 
         class TheTestWithLocalType {
             @InjectMocks LocalType field;
         }
 
         TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();
 
         // when
         new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));
     }
 
     @Test
     public void should_not_fail_if_local_type_field_is_instantiated() throws Exception {
         // when
         class LocalType { }
 
         class TheTestWithLocalType {
             @InjectMocks LocalType field = new LocalType();
         }
 
         TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();
 
         // when
         new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));
     }
 
     @Test(expected = MockitoException.class)
     public void should_fail_for_inner_class_field() throws Exception {
         new FieldInitializer(this, field("innerClassType"));
     }
 
     @Test
     public void should_not_fail_if_inner_class_field_is_instantiated() throws Exception {
         new FieldInitializer(this, field("instantiatedInnerClassType"));
     }
 
     @Test
     public void can_instantiate_class_with_parameterized_constructor() throws Exception {
         ConstructorArgumentResolver resolver = given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class[].class)))
                         .willReturn(new Object[]{null}).getMock();
 
         new FieldInitializer(this, field("noDefaultConstructor"), resolver).initialize();
 
         assertNotNull(noDefaultConstructor);
     }
 
     private Field field(String fieldName) throws NoSuchFieldException {
         return this.getClass().getDeclaredField(fieldName);
     }
 
     static class StaticClass {
     }
 
     static class StaticClassWithDefaultConstructor {
         StaticClassWithDefaultConstructor() { }
     }
 
     static class StaticClassWithPrivateDefaultConstructor {
         private StaticClassWithPrivateDefaultConstructor() { }
     }
 
     static class StaticClassWithoutDefaultConstructor {
         private StaticClassWithoutDefaultConstructor(String param) { }
     }
 
     static class StaticClassThrowingExceptionDefaultConstructor {
         StaticClassThrowingExceptionDefaultConstructor() throws Exception {
             throw new NullPointerException("business logic failed");
         }
     }
     
     static abstract class AbstractStaticClass {
         public AbstractStaticClass() {}
     }
 
-    static interface Interface {
+    interface Interface {
 
     }
 
     static class ConcreteStaticClass extends AbstractStaticClass implements Interface {
     }
 
     class InnerClassType {
         InnerClassType() { }
     }
 
 }

commit e989b7e84b4f9b2e5b3b70e766d6215fd68fcb3b
Author: Brice <brice.dutheil@gmail.com>
Date:   Fri Oct 7 13:23:30 2011

    minor tweaks regarding field initialization and javadocs

diff --git a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
--- a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
+++ b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
@@ -6,199 +6,203 @@
 package org.mockito.internal.util.reflection;
 
 import org.junit.Test;
 import org.mockito.InjectMocks;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 
 import static org.junit.Assert.*;
 import static org.mockito.BDDMockito.given;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.mock;
 
 
 
 public class FieldInitializerTest {
 
     private StaticClass alreadyInstantiated = new StaticClass();
     private StaticClass noConstructor;
     private StaticClassWithDefaultConstructor defaultConstructor;
     private StaticClassWithPrivateDefaultConstructor privateDefaultConstructor;
     private StaticClassWithoutDefaultConstructor noDefaultConstructor;
     private StaticClassThrowingExceptionDefaultConstructor throwingExDefaultConstructor;
     private AbstractStaticClass abstractType;
     private Interface interfaceType;
     private InnerClassType innerClassType;
     private AbstractStaticClass instantiatedAbstractType = new ConcreteStaticClass();
     private Interface instantiatedInterfaceType =  new ConcreteStaticClass();
     private InnerClassType instantiatedInnerClassType = new InnerClassType();
 
     @Test
     public void should_keep_same_instance_if_field_initialized() throws Exception {
         final StaticClass backupInstance = alreadyInstantiated;
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("alreadyInstantiated"));
         FieldInitializationReport report = fieldInitializer.initialize();
 
         assertSame(backupInstance, report.fieldInstance());
         assertFalse(report.fieldWasInitialized());
+        assertFalse(report.fieldWasInitializedUsingContructorArgs());
     }
 
     @Test
     public void should_instantiate_field_when_type_has_no_constructor() throws Exception {
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("noConstructor"));
         FieldInitializationReport report = fieldInitializer.initialize();
 
         assertNotNull(report.fieldInstance());
         assertTrue(report.fieldWasInitialized());
+        assertFalse(report.fieldWasInitializedUsingContructorArgs());
     }
 
     @Test
     public void should_instantiate_field_with_default_constructor() throws Exception {
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("defaultConstructor"));
         FieldInitializationReport report = fieldInitializer.initialize();
 
         assertNotNull(report.fieldInstance());
         assertTrue(report.fieldWasInitialized());
+        assertFalse(report.fieldWasInitializedUsingContructorArgs());
     }
 
     @Test
     public void should_instantiate_field_with_private_default_constructor() throws Exception {
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("privateDefaultConstructor"));
         FieldInitializationReport report = fieldInitializer.initialize();
 
         assertNotNull(report.fieldInstance());
         assertTrue(report.fieldWasInitialized());
+        assertFalse(report.fieldWasInitializedUsingContructorArgs());
     }
 
     @Test(expected = MockitoException.class)
     public void should_fail_to_instantiate_field_if_no_default_constructor() throws Exception {
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("noDefaultConstructor"));
         fieldInitializer.initialize();
     }
 
     @Test
     public void should_fail_to_instantiate_field_if_default_constructor_throws_exception() throws Exception {
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("throwingExDefaultConstructor"));
         try {
             fieldInitializer.initialize();
             fail();
         } catch (MockitoException e) {
             InvocationTargetException ite = (InvocationTargetException) e.getCause();
             assertTrue(ite.getTargetException() instanceof NullPointerException);
             assertEquals("business logic failed", ite.getTargetException().getMessage());
         }
     }
 
     @Test(expected = MockitoException.class)
     public void should_fail_for_abstract_field() throws Exception {
         new FieldInitializer(this, field("abstractType"));
     }
 
     @Test
     public void should_not_fail_if_abstract_field_is_instantiated() throws Exception {
         new FieldInitializer(this, field("instantiatedAbstractType"));
     }
 
     @Test(expected = MockitoException.class)
     public void should_fail_for_interface_field() throws Exception {
         new FieldInitializer(this, field("interfaceType"));
     }
 
     @Test
     public void should_not_fail_if_interface_field_is_instantiated() throws Exception {
         new FieldInitializer(this, field("instantiatedInterfaceType"));
     }
 
     @Test(expected = MockitoException.class)
     public void should_fail_for_local_type_field() throws Exception {
         // when
         class LocalType { }
 
         class TheTestWithLocalType {
             @InjectMocks LocalType field;
         }
 
         TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();
 
         // when
         new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));
     }
 
     @Test
     public void should_not_fail_if_local_type_field_is_instantiated() throws Exception {
         // when
         class LocalType { }
 
         class TheTestWithLocalType {
             @InjectMocks LocalType field = new LocalType();
         }
 
         TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();
 
         // when
         new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));
     }
 
     @Test(expected = MockitoException.class)
     public void should_fail_for_inner_class_field() throws Exception {
         new FieldInitializer(this, field("innerClassType"));
     }
 
     @Test
     public void should_not_fail_if_inner_class_field_is_instantiated() throws Exception {
         new FieldInitializer(this, field("instantiatedInnerClassType"));
     }
 
     @Test
     public void can_instantiate_class_with_parameterized_constructor() throws Exception {
         ConstructorArgumentResolver resolver = given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class[].class)))
                         .willReturn(new Object[]{null}).getMock();
 
         new FieldInitializer(this, field("noDefaultConstructor"), resolver).initialize();
 
         assertNotNull(noDefaultConstructor);
     }
 
     private Field field(String fieldName) throws NoSuchFieldException {
         return this.getClass().getDeclaredField(fieldName);
     }
 
     static class StaticClass {
     }
 
     static class StaticClassWithDefaultConstructor {
         StaticClassWithDefaultConstructor() { }
     }
 
     static class StaticClassWithPrivateDefaultConstructor {
         private StaticClassWithPrivateDefaultConstructor() { }
     }
 
     static class StaticClassWithoutDefaultConstructor {
         private StaticClassWithoutDefaultConstructor(String param) { }
     }
 
     static class StaticClassThrowingExceptionDefaultConstructor {
         StaticClassThrowingExceptionDefaultConstructor() throws Exception {
             throw new NullPointerException("business logic failed");
         }
     }
     
     static abstract class AbstractStaticClass {
         public AbstractStaticClass() {}
     }
 
     static interface Interface {
 
     }
 
     static class ConcreteStaticClass extends AbstractStaticClass implements Interface {
     }
 
     class InnerClassType {
         InnerClassType() { }
     }
 
 }

commit 5a4cdb5a40542e01c1558f7fbc34df01cfa794aa
Author: Brice <brice.dutheil@gmail.com>
Date:   Sun Mar 20 12:17:11 2011

    issue 238 : constructor injection is now alive :
     - inject declared mocks only
     - fail silently for now allowing people to instantiate fields themselves (however some error will need to be reported)
     - @Spy and @InjectMocks with constructor injection don't work together.
    
    --HG--
    branch : issue 238 : constructor injection
    rename : test/org/mockitousage/annotation/InjectMocksTest.java => test/org/mockitousage/annotation/MockInjectionUsingConstructorTest.java
    rename : test/org/mockitousage/annotation/MockInjectionTest.java => test/org/mockitousage/annotation/MockInjectionUsingSetterOrPropertyTest.java

diff --git a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
--- a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
+++ b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
@@ -1,187 +1,199 @@
 package org.mockito.internal.util.reflection;
 
 import org.junit.Test;
 import org.mockito.InjectMocks;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 
 import static org.junit.Assert.*;
 import static org.mockito.BDDMockito.given;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.mock;
 
 
 
 public class FieldInitializerTest {
 
     private StaticClass alreadyInstantiated = new StaticClass();
     private StaticClass noConstructor;
     private StaticClassWithDefaultConstructor defaultConstructor;
     private StaticClassWithPrivateDefaultConstructor privateDefaultConstructor;
     private StaticClassWithoutDefaultConstructor noDefaultConstructor;
     private StaticClassThrowingExceptionDefaultConstructor throwingExDefaultConstructor;
     private AbstractStaticClass abstractType;
     private Interface interfaceType;
     private InnerClassType innerClassType;
     private AbstractStaticClass instantiatedAbstractType = new ConcreteStaticClass();
     private Interface instantiatedInterfaceType =  new ConcreteStaticClass();
     private InnerClassType instantiatedInnerClassType = new InnerClassType();
 
     @Test
     public void should_keep_same_instance_if_field_initialized() throws Exception {
         final StaticClass backupInstance = alreadyInstantiated;
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("alreadyInstantiated"));
-        assertSame(backupInstance, fieldInitializer.initialize());
+        FieldInitializationReport report = fieldInitializer.initialize();
+
+        assertSame(backupInstance, report.fieldInstance());
+        assertFalse(report.fieldWasInitialized());
     }
 
     @Test
     public void should_instantiate_field_when_type_has_no_constructor() throws Exception {
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("noConstructor"));
-        assertNotNull(fieldInitializer.initialize());
+        FieldInitializationReport report = fieldInitializer.initialize();
+
+        assertNotNull(report.fieldInstance());
+        assertTrue(report.fieldWasInitialized());
     }
 
     @Test
     public void should_instantiate_field_with_default_constructor() throws Exception {
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("defaultConstructor"));
-        assertNotNull(fieldInitializer.initialize());
+        FieldInitializationReport report = fieldInitializer.initialize();
+
+        assertNotNull(report.fieldInstance());
+        assertTrue(report.fieldWasInitialized());
     }
 
     @Test
     public void should_instantiate_field_with_private_default_constructor() throws Exception {
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("privateDefaultConstructor"));
-        assertNotNull(fieldInitializer.initialize());
+        FieldInitializationReport report = fieldInitializer.initialize();
+
+        assertNotNull(report.fieldInstance());
+        assertTrue(report.fieldWasInitialized());
     }
 
     @Test(expected = MockitoException.class)
     public void should_fail_to_instantiate_field_if_no_default_constructor() throws Exception {
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("noDefaultConstructor"));
         fieldInitializer.initialize();
     }
 
     @Test
     public void should_fail_to_instantiate_field_if_default_constructor_throws_exception() throws Exception {
         FieldInitializer fieldInitializer = new FieldInitializer(this, field("throwingExDefaultConstructor"));
         try {
             fieldInitializer.initialize();
             fail();
         } catch (MockitoException e) {
             InvocationTargetException ite = (InvocationTargetException) e.getCause();
             assertTrue(ite.getTargetException() instanceof NullPointerException);
             assertEquals("business logic failed", ite.getTargetException().getMessage());
         }
     }
 
     @Test(expected = MockitoException.class)
     public void should_fail_for_abstract_field() throws Exception {
         new FieldInitializer(this, field("abstractType"));
     }
 
     @Test
     public void should_not_fail_if_abstract_field_is_instantiated() throws Exception {
         new FieldInitializer(this, field("instantiatedAbstractType"));
     }
 
     @Test(expected = MockitoException.class)
     public void should_fail_for_interface_field() throws Exception {
         new FieldInitializer(this, field("interfaceType"));
     }
 
     @Test
     public void should_not_fail_if_interface_field_is_instantiated() throws Exception {
         new FieldInitializer(this, field("instantiatedInterfaceType"));
     }
 
     @Test(expected = MockitoException.class)
     public void should_fail_for_local_type_field() throws Exception {
         // when
         class LocalType { }
 
         class TheTestWithLocalType {
             @InjectMocks LocalType field;
         }
 
         TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();
 
         // when
         new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));
     }
 
     @Test
     public void should_not_fail_if_local_type_field_is_instantiated() throws Exception {
         // when
         class LocalType { }
 
         class TheTestWithLocalType {
             @InjectMocks LocalType field = new LocalType();
         }
 
         TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();
 
         // when
         new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));
     }
 
     @Test(expected = MockitoException.class)
     public void should_fail_for_inner_class_field() throws Exception {
         new FieldInitializer(this, field("innerClassType"));
     }
 
     @Test
     public void should_not_fail_if_inner_class_field_is_instantiated() throws Exception {
         new FieldInitializer(this, field("instantiatedInnerClassType"));
     }
 
     @Test
     public void can_instantiate_class_with_parameterized_constructor() throws Exception {
         ConstructorArgumentResolver resolver = given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class[].class)))
-                        .willReturn(new Object[] { null }).getMock();
+                        .willReturn(new Object[]{null}).getMock();
 
         new FieldInitializer(this, field("noDefaultConstructor"), resolver).initialize();
 
         assertNotNull(noDefaultConstructor);
     }
 
     private Field field(String fieldName) throws NoSuchFieldException {
         return this.getClass().getDeclaredField(fieldName);
     }
 
     static class StaticClass {
     }
 
     static class StaticClassWithDefaultConstructor {
         StaticClassWithDefaultConstructor() { }
     }
 
     static class StaticClassWithPrivateDefaultConstructor {
         private StaticClassWithPrivateDefaultConstructor() { }
     }
 
     static class StaticClassWithoutDefaultConstructor {
         private StaticClassWithoutDefaultConstructor(String param) { }
     }
 
     static class StaticClassThrowingExceptionDefaultConstructor {
         StaticClassThrowingExceptionDefaultConstructor() throws Exception {
             throw new NullPointerException("business logic failed");
         }
     }
     
     static abstract class AbstractStaticClass {
         public AbstractStaticClass() {}
     }
 
     static interface Interface {
 
     }
 
     static class ConcreteStaticClass extends AbstractStaticClass implements Interface {
     }
 
     class InnerClassType {
         InnerClassType() { }
     }
 
 }

commit 377de51ddf90e01c50646f34e353bbf01844c677
Author: Brice <brice.dutheil@gmail.com>
Date:   Wed Mar 16 21:19:45 2011

    issue 238 : reworked inject mocks engine to allow constructor injection, constructor injection is still a work in progress
    
    --HG--
    branch : issue 238 : constructor injection
    rename : src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java => src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java
    rename : src/org/mockito/internal/configuration/injection/MockCandidateFilter.java => src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java
    rename : src/org/mockito/internal/configuration/injection/NameBasedCandidateFilter.java => src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java
    rename : src/org/mockito/internal/configuration/injection/OngoingInjecter.java => src/org/mockito/internal/configuration/injection/filter/OngoingInjecter.java
    rename : src/org/mockito/internal/configuration/injection/TypeBasedCandidateFilter.java => src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java
    rename : src/org/mockito/internal/util/reflection/ConstructorInitializer.java => src/org/mockito/internal/util/reflection/FieldConstructorInitializer.java

diff --git a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
--- a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
+++ b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
@@ -1,162 +1,187 @@
 package org.mockito.internal.util.reflection;
 
 import org.junit.Test;
 import org.mockito.InjectMocks;
 import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;
 
+import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 
 import static org.junit.Assert.*;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.mock;
+
+
 
 public class FieldInitializerTest {
 
     private StaticClass alreadyInstantiated = new StaticClass();
     private StaticClass noConstructor;
     private StaticClassWithDefaultConstructor defaultConstructor;
     private StaticClassWithPrivateDefaultConstructor privateDefaultConstructor;
     private StaticClassWithoutDefaultConstructor noDefaultConstructor;
     private StaticClassThrowingExceptionDefaultConstructor throwingExDefaultConstructor;
     private AbstractStaticClass abstractType;
     private Interface interfaceType;
     private InnerClassType innerClassType;
     private AbstractStaticClass instantiatedAbstractType = new ConcreteStaticClass();
     private Interface instantiatedInterfaceType =  new ConcreteStaticClass();
     private InnerClassType instantiatedInnerClassType = new InnerClassType();
 
     @Test
-    public void shouldKeepSameInstanceIfFieldInitialized() throws Exception {
+    public void should_keep_same_instance_if_field_initialized() throws Exception {
         final StaticClass backupInstance = alreadyInstantiated;
-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField("alreadyInstantiated"));
+        FieldInitializer fieldInitializer = new FieldInitializer(this, field("alreadyInstantiated"));
         assertSame(backupInstance, fieldInitializer.initialize());
     }
 
     @Test
-    public void shouldInstantiateFieldWhenTypeHasNoConstructor() throws Exception {
-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField("noConstructor"));
+    public void should_instantiate_field_when_type_has_no_constructor() throws Exception {
+        FieldInitializer fieldInitializer = new FieldInitializer(this, field("noConstructor"));
         assertNotNull(fieldInitializer.initialize());
     }
 
     @Test
-    public void shouldInstantiateFieldWithDefaultConstructor() throws Exception {
-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField("defaultConstructor"));
+    public void should_instantiate_field_with_default_constructor() throws Exception {
+        FieldInitializer fieldInitializer = new FieldInitializer(this, field("defaultConstructor"));
         assertNotNull(fieldInitializer.initialize());
     }
 
     @Test
-    public void shouldInstantiateFieldWithPrivateDefaultConstructor() throws Exception {
-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField("privateDefaultConstructor"));
+    public void should_instantiate_field_with_private_default_constructor() throws Exception {
+        FieldInitializer fieldInitializer = new FieldInitializer(this, field("privateDefaultConstructor"));
         assertNotNull(fieldInitializer.initialize());
     }
 
     @Test(expected = MockitoException.class)
-    public void shouldFailToInstantiateFieldIfNoDefaultConstructor() throws Exception {
-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField("noDefaultConstructor"));
+    public void should_fail_to_instantiate_field_if_no_default_constructor() throws Exception {
+        FieldInitializer fieldInitializer = new FieldInitializer(this, field("noDefaultConstructor"));
         fieldInitializer.initialize();
     }
 
     @Test
-    public void shouldFailToInstantiateFieldIfDefaultConstructorThrowsException() throws Exception {
-        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField("throwingExDefaultConstructor"));
+    public void should_fail_to_instantiate_field_if_default_constructor_throws_exception() throws Exception {
+        FieldInitializer fieldInitializer = new FieldInitializer(this, field("throwingExDefaultConstructor"));
         try {
             fieldInitializer.initialize();
             fail();
         } catch (MockitoException e) {
             InvocationTargetException ite = (InvocationTargetException) e.getCause();
             assertTrue(ite.getTargetException() instanceof NullPointerException);
             assertEquals("business logic failed", ite.getTargetException().getMessage());
         }
     }
 
     @Test(expected = MockitoException.class)
-    public void shouldFailForAbstractField() throws Exception {
-        new FieldInitializer(this, this.getClass().getDeclaredField("abstractType"));
+    public void should_fail_for_abstract_field() throws Exception {
+        new FieldInitializer(this, field("abstractType"));
     }
 
-    public void shouldNotFailIfAbstractFieldIsInstantiated() throws Exception {
-        new FieldInitializer(this, this.getClass().getDeclaredField("instantiatedAbstractType"));
+    @Test
+    public void should_not_fail_if_abstract_field_is_instantiated() throws Exception {
+        new FieldInitializer(this, field("instantiatedAbstractType"));
     }
 
     @Test(expected = MockitoException.class)
-    public void shouldFailForInterfaceField() throws Exception {
-        new FieldInitializer(this, this.getClass().getDeclaredField("interfaceType"));
+    public void should_fail_for_interface_field() throws Exception {
+        new FieldInitializer(this, field("interfaceType"));
     }
 
-    public void shouldNotFailIfInterfaceFieldIsInstantiated() throws Exception {
-        new FieldInitializer(this, this.getClass().getDeclaredField("instantiatedInterfaceType"));
+    @Test
+    public void should_not_fail_if_interface_field_is_instantiated() throws Exception {
+        new FieldInitializer(this, field("instantiatedInterfaceType"));
     }
 
     @Test(expected = MockitoException.class)
-    public void shouldFailForLocalTypeField() throws Exception {
+    public void should_fail_for_local_type_field() throws Exception {
         // when
-        class LocalType { };
+        class LocalType { }
 
         class TheTestWithLocalType {
             @InjectMocks LocalType field;
         }
 
         TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();
 
         // when
         new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));
     }
 
-    public void shouldNotFailIfLocalTypeFieldIsInstantiated() throws Exception {
+    @Test
+    public void should_not_fail_if_local_type_field_is_instantiated() throws Exception {
         // when
-        class LocalType { };
+        class LocalType { }
 
         class TheTestWithLocalType {
             @InjectMocks LocalType field = new LocalType();
         }
 
         TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();
 
         // when
         new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));
     }
 
     @Test(expected = MockitoException.class)
-    public void shouldFailForInnerClassField() throws Exception {
-        new FieldInitializer(this, this.getClass().getDeclaredField("innerClassType"));
+    public void should_fail_for_inner_class_field() throws Exception {
+        new FieldInitializer(this, field("innerClassType"));
+    }
+
+    @Test
+    public void should_not_fail_if_inner_class_field_is_instantiated() throws Exception {
+        new FieldInitializer(this, field("instantiatedInnerClassType"));
+    }
+
+    @Test
+    public void can_instantiate_class_with_parameterized_constructor() throws Exception {
+        ConstructorArgumentResolver resolver = given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class[].class)))
+                        .willReturn(new Object[] { null }).getMock();
+
+        new FieldInitializer(this, field("noDefaultConstructor"), resolver).initialize();
+
+        assertNotNull(noDefaultConstructor);
     }
 
-    public void shouldNotFailIfInnerClassFieldIsInstantiated() throws Exception {
-        new FieldInitializer(this, this.getClass().getDeclaredField("instantiatedInnerClassType"));
+    private Field field(String fieldName) throws NoSuchFieldException {
+        return this.getClass().getDeclaredField(fieldName);
     }
 
     static class StaticClass {
     }
 
     static class StaticClassWithDefaultConstructor {
         StaticClassWithDefaultConstructor() { }
     }
 
     static class StaticClassWithPrivateDefaultConstructor {
         private StaticClassWithPrivateDefaultConstructor() { }
     }
 
     static class StaticClassWithoutDefaultConstructor {
         private StaticClassWithoutDefaultConstructor(String param) { }
     }
 
     static class StaticClassThrowingExceptionDefaultConstructor {
         StaticClassThrowingExceptionDefaultConstructor() throws Exception {
             throw new NullPointerException("business logic failed");
         }
     }
     
     static abstract class AbstractStaticClass {
         public AbstractStaticClass() {}
     }
 
     static interface Interface {
 
     }
 
     static class ConcreteStaticClass extends AbstractStaticClass implements Interface {
     }
 
     class InnerClassType {
         InnerClassType() { }
     }
 
 }

commit 93863606a5b4d3f496467cb9e62016cef354bb56
Author: Brice Dutheil <brice.dutheil@gmail.com>
Date:   Mon Oct 18 12:15:05 2010

    issue209 : @InjectMocks and @Spy annotated field initialization

diff --git a/test/org/mockito/internal/util/reflection/FieldInitializerTest.java b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
--- /dev/null
+++ b/test/org/mockito/internal/util/reflection/FieldInitializerTest.java
@@ -0,0 +1,162 @@
+package org.mockito.internal.util.reflection;
+
+import org.junit.Test;
+import org.mockito.InjectMocks;
+import org.mockito.exceptions.base.MockitoException;
+
+import java.lang.reflect.InvocationTargetException;
+
+import static org.junit.Assert.*;
+
+public class FieldInitializerTest {
+
+    private StaticClass alreadyInstantiated = new StaticClass();
+    private StaticClass noConstructor;
+    private StaticClassWithDefaultConstructor defaultConstructor;
+    private StaticClassWithPrivateDefaultConstructor privateDefaultConstructor;
+    private StaticClassWithoutDefaultConstructor noDefaultConstructor;
+    private StaticClassThrowingExceptionDefaultConstructor throwingExDefaultConstructor;
+    private AbstractStaticClass abstractType;
+    private Interface interfaceType;
+    private InnerClassType innerClassType;
+    private AbstractStaticClass instantiatedAbstractType = new ConcreteStaticClass();
+    private Interface instantiatedInterfaceType =  new ConcreteStaticClass();
+    private InnerClassType instantiatedInnerClassType = new InnerClassType();
+
+    @Test
+    public void shouldKeepSameInstanceIfFieldInitialized() throws Exception {
+        final StaticClass backupInstance = alreadyInstantiated;
+        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField("alreadyInstantiated"));
+        assertSame(backupInstance, fieldInitializer.initialize());
+    }
+
+    @Test
+    public void shouldInstantiateFieldWhenTypeHasNoConstructor() throws Exception {
+        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField("noConstructor"));
+        assertNotNull(fieldInitializer.initialize());
+    }
+
+    @Test
+    public void shouldInstantiateFieldWithDefaultConstructor() throws Exception {
+        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField("defaultConstructor"));
+        assertNotNull(fieldInitializer.initialize());
+    }
+
+    @Test
+    public void shouldInstantiateFieldWithPrivateDefaultConstructor() throws Exception {
+        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField("privateDefaultConstructor"));
+        assertNotNull(fieldInitializer.initialize());
+    }
+
+    @Test(expected = MockitoException.class)
+    public void shouldFailToInstantiateFieldIfNoDefaultConstructor() throws Exception {
+        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField("noDefaultConstructor"));
+        fieldInitializer.initialize();
+    }
+
+    @Test
+    public void shouldFailToInstantiateFieldIfDefaultConstructorThrowsException() throws Exception {
+        FieldInitializer fieldInitializer = new FieldInitializer(this, this.getClass().getDeclaredField("throwingExDefaultConstructor"));
+        try {
+            fieldInitializer.initialize();
+            fail();
+        } catch (MockitoException e) {
+            InvocationTargetException ite = (InvocationTargetException) e.getCause();
+            assertTrue(ite.getTargetException() instanceof NullPointerException);
+            assertEquals("business logic failed", ite.getTargetException().getMessage());
+        }
+    }
+
+    @Test(expected = MockitoException.class)
+    public void shouldFailForAbstractField() throws Exception {
+        new FieldInitializer(this, this.getClass().getDeclaredField("abstractType"));
+    }
+
+    public void shouldNotFailIfAbstractFieldIsInstantiated() throws Exception {
+        new FieldInitializer(this, this.getClass().getDeclaredField("instantiatedAbstractType"));
+    }
+
+    @Test(expected = MockitoException.class)
+    public void shouldFailForInterfaceField() throws Exception {
+        new FieldInitializer(this, this.getClass().getDeclaredField("interfaceType"));
+    }
+
+    public void shouldNotFailIfInterfaceFieldIsInstantiated() throws Exception {
+        new FieldInitializer(this, this.getClass().getDeclaredField("instantiatedInterfaceType"));
+    }
+
+    @Test(expected = MockitoException.class)
+    public void shouldFailForLocalTypeField() throws Exception {
+        // when
+        class LocalType { };
+
+        class TheTestWithLocalType {
+            @InjectMocks LocalType field;
+        }
+
+        TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();
+
+        // when
+        new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));
+    }
+
+    public void shouldNotFailIfLocalTypeFieldIsInstantiated() throws Exception {
+        // when
+        class LocalType { };
+
+        class TheTestWithLocalType {
+            @InjectMocks LocalType field = new LocalType();
+        }
+
+        TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();
+
+        // when
+        new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));
+    }
+
+    @Test(expected = MockitoException.class)
+    public void shouldFailForInnerClassField() throws Exception {
+        new FieldInitializer(this, this.getClass().getDeclaredField("innerClassType"));
+    }
+
+    public void shouldNotFailIfInnerClassFieldIsInstantiated() throws Exception {
+        new FieldInitializer(this, this.getClass().getDeclaredField("instantiatedInnerClassType"));
+    }
+
+    static class StaticClass {
+    }
+
+    static class StaticClassWithDefaultConstructor {
+        StaticClassWithDefaultConstructor() { }
+    }
+
+    static class StaticClassWithPrivateDefaultConstructor {
+        private StaticClassWithPrivateDefaultConstructor() { }
+    }
+
+    static class StaticClassWithoutDefaultConstructor {
+        private StaticClassWithoutDefaultConstructor(String param) { }
+    }
+
+    static class StaticClassThrowingExceptionDefaultConstructor {
+        StaticClassThrowingExceptionDefaultConstructor() throws Exception {
+            throw new NullPointerException("business logic failed");
+        }
+    }
+    
+    static abstract class AbstractStaticClass {
+        public AbstractStaticClass() {}
+    }
+
+    static interface Interface {
+
+    }
+
+    static class ConcreteStaticClass extends AbstractStaticClass implements Interface {
+    }
+
+    class InnerClassType {
+        InnerClassType() { }
+    }
+
+}
