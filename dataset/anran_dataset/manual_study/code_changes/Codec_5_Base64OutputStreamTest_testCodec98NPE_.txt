commit 800f0531068ebaf2f2d257bb1bd805781ddd4760
Author: Julius Davies <julius@apache.org>
Date:   Tue Jun 1 17:52:33 2010

    CODEC-98 - Base64InputStream causes NullPointerException on some input - https://issues.apache.org/jira/browse/CODEC-98
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@950267 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
--- a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
@@ -50,5 +55,23 @@
+    public void testCodec98NPE() throws Exception {
+        byte[] codec98 = StringUtils.getBytesUtf8(Base64TestData.CODEC_98_NPE);
+        byte[] codec98_1024 = new byte[1024];
+        System.arraycopy(codec98, 0, codec98_1024, 0, codec98.length);
+        ByteArrayOutputStream data = new ByteArrayOutputStream(1024);
+        Base64OutputStream stream = new Base64OutputStream(data, false);
+        stream.write(codec98_1024, 0, 1024);
+        stream.close();
+
+        byte[] decodedBytes = data.toByteArray();
+        String decoded = StringUtils.newStringUtf8(decodedBytes);
+        assertEquals(
+            "codec-98 NPE Base64OutputStream", Base64TestData.CODEC_98_NPE_DECODED, decoded
+        );
+    }
+    
+
+    /**
      * Test the Base64OutputStream implementation against empty input.
      * 
      * @throws Exception
      *             for some failure scenarios.
      */

commit d6ce22b75c7d06e24dc2994529dfa79a09016f04
Author: Niall Kegan Pemberton <niallp@apache.org>
Date:   Wed Jul 22 21:46:50 2009

    set svn:eol-style to native
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@796922 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
--- a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
@@ -1,310 +50,5 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.binary;
-
-import java.io.ByteArrayOutputStream;
-import java.io.OutputStream;
-import java.util.Arrays;
-
-import junit.framework.TestCase;
-
-/**
- * @author Apache Software Foundation
- * @version $Id $
- * @since 1.4
- */
-public class Base64OutputStreamTest extends TestCase {
-
-    private final static byte[] CRLF = {(byte) '\r', (byte) '\n'};
-
-    private final static byte[] LF = {(byte) '\n'};
-
-    private static final String STRING_FIXTURE = "Hello World";
-
-    /**
-     * Construct a new instance of this test case.
-     * 
-     * @param name
-     *            Name of the test case
-     */
-    public Base64OutputStreamTest(String name) {
-        super(name);
-    }
-
-    /**
-     * Test the Base64OutputStream implementation against empty input.
-     * 
-     * @throws Exception
-     *             for some failure scenarios.
-     */
-    public void testBase64EmptyOutputStream() throws Exception {
-        byte[] emptyEncoded = new byte[0];
-        byte[] emptyDecoded = new byte[0];
-        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);
-        testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);
-    }
-
-    /**
-     * Test the Base64OutputStream implementation
-     * 
-     * @throws Exception
-     *             for some failure scenarios.
-     */
-    public void testBase64OutputStreamByChunk() throws Exception {
-        // Hello World test.
-        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
-        testByChunk(encoded, decoded, 76, CRLF);
-
-        // Single Byte test.
-        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
-        decoded = new byte[]{(byte) 0};
-        testByChunk(encoded, decoded, 76, CRLF);
-
-        // OpenSSL interop test.
-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);
-        decoded = Base64TestData.DECODED;
-        testByChunk(encoded, decoded, 64, LF);
-
-        // Single Line test.
-        String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
-        encoded = StringBytesUtils.getBytesUtf8(singleLine);
-        decoded = Base64TestData.DECODED;
-        testByChunk(encoded, decoded, 0, LF);
-
-        // test random data of sizes 0 thru 150
-        for (int i = 0; i <= 150; i++) {
-            byte[][] randomData = Base64TestData.randomData(i, false);
-            encoded = randomData[1];
-            decoded = randomData[0];
-            testByChunk(encoded, decoded, 0, LF);
-        }
-    }
-
-    /**
-     * Test the Base64OutputStream implementation
-     * 
-     * @throws Exception
-     *             for some failure scenarios.
-     */
-    public void testBase64OutputStreamByteByByte() throws Exception {
-        // Hello World test.
-        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
-        testByteByByte(encoded, decoded, 76, CRLF);
-
-        // Single Byte test.
-        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
-        decoded = new byte[]{(byte) 0};
-        testByteByByte(encoded, decoded, 76, CRLF);
-
-        // OpenSSL interop test.
-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);
-        decoded = Base64TestData.DECODED;
-        testByteByByte(encoded, decoded, 64, LF);
-
-        // Single Line test.
-        String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
-        encoded = StringBytesUtils.getBytesUtf8(singleLine);
-        decoded = Base64TestData.DECODED;
-        testByteByByte(encoded, decoded, 0, LF);
-
-        // test random data of sizes 0 thru 150
-        for (int i = 0; i <= 150; i++) {
-            byte[][] randomData = Base64TestData.randomData(i, false);
-            encoded = randomData[1];
-            decoded = randomData[0];
-            testByteByByte(encoded, decoded, 0, LF);
-        }
-    }
-
-    /**
-     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
-     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
-     * <p/>
-     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64OutputStream wraps itself in encode and decode
-     * mode over and over again.
-     * 
-     * @param encoded
-     *            base64 encoded data
-     * @param decoded
-     *            the data from above, but decoded
-     * @param chunkSize
-     *            chunk size (line-length) of the base64 encoded data.
-     * @param seperator
-     *            Line separator in the base64 encoded data.
-     * @throws Exception
-     *             Usually signifies a bug in the Base64 commons-codec implementation.
-     */
-    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
-
-        // Start with encode.
-        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
-        OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);
-        out.write(decoded);
-        out.close();
-        byte[] output = byteOut.toByteArray();
-        assertTrue("Streaming chunked base64 encode", Arrays.equals(output, encoded));
-
-        // Now let's try decode.
-        byteOut = new ByteArrayOutputStream();
-        out = new Base64OutputStream(byteOut, false);
-        out.write(encoded);
-        out.close();
-        output = byteOut.toByteArray();
-        assertTrue("Streaming chunked base64 decode", Arrays.equals(output, decoded));
-
-        // I always wanted to do this! (wrap encoder with decoder etc etc).
-        byteOut = new ByteArrayOutputStream();
-        out = byteOut;
-        for (int i = 0; i < 10; i++) {
-            out = new Base64OutputStream(out, false);
-            out = new Base64OutputStream(out, true, chunkSize, seperator);
-        }
-        out.write(decoded);
-        out.close();
-        output = byteOut.toByteArray();
-
-        assertTrue("Streaming chunked base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
-    }
-
-    /**
-     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
-     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
-     * <p/>
-     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64OutputStream wraps itself in encode and decode
-     * mode over and over again.
-     * 
-     * @param encoded
-     *            base64 encoded data
-     * @param decoded
-     *            the data from above, but decoded
-     * @param chunkSize
-     *            chunk size (line-length) of the base64 encoded data.
-     * @param seperator
-     *            Line separator in the base64 encoded data.
-     * @throws Exception
-     *             Usually signifies a bug in the Base64 commons-codec implementation.
-     */
-    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
-
-        // Start with encode.
-        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
-        OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);
-        for (int i = 0; i < decoded.length; i++) {
-            out.write(decoded[i]);
-        }
-        out.close();
-        byte[] output = byteOut.toByteArray();
-        assertTrue("Streaming byte-by-byte base64 encode", Arrays.equals(output, encoded));
-
-        // Now let's try decode.
-        byteOut = new ByteArrayOutputStream();
-        out = new Base64OutputStream(byteOut, false);
-        for (int i = 0; i < encoded.length; i++) {
-            out.write(encoded[i]);
-        }
-        out.close();
-        output = byteOut.toByteArray();
-        assertTrue("Streaming byte-by-byte base64 decode", Arrays.equals(output, decoded));
-
-        // Now let's try decode with tonnes of flushes.
-        byteOut = new ByteArrayOutputStream();
-        out = new Base64OutputStream(byteOut, false);
-        for (int i = 0; i < encoded.length; i++) {
-            out.write(encoded[i]);
-            out.flush();
-        }
-        out.close();
-        output = byteOut.toByteArray();
-        assertTrue("Streaming byte-by-byte flush() base64 decode", Arrays.equals(output, decoded));
-
-        // I always wanted to do this! (wrap encoder with decoder etc etc).
-        byteOut = new ByteArrayOutputStream();
-        out = byteOut;
-        for (int i = 0; i < 10; i++) {
-            out = new Base64OutputStream(out, false);
-            out = new Base64OutputStream(out, true, chunkSize, seperator);
-        }
-        for (int i = 0; i < decoded.length; i++) {
-            out.write(decoded[i]);
-        }
-        out.close();
-        output = byteOut.toByteArray();
-
-        assertTrue("Streaming byte-by-byte base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
-    }
-
-    /**
-     * Tests Base64OutputStream.write for expected IndexOutOfBoundsException conditions.
-     * 
-     * @throws Exception
-     *             for some failure scenarios.
-     */
-    public void testWriteOutOfBounds() throws Exception {
-        byte[] buf = new byte[1024];
-        ByteArrayOutputStream bout = new ByteArrayOutputStream();
-        Base64OutputStream out = new Base64OutputStream(bout);
-
-        try {
-            out.write(buf, -1, 1);
-            fail("Expected Base64OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException");
-        } catch (IndexOutOfBoundsException ioobe) {
-            // Expected
-        }
-
-        try {
-            out.write(buf, 1, -1);
-            fail("Expected Base64OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException");
-        } catch (IndexOutOfBoundsException ioobe) {
-            // Expected
-        }
-
-        try {
-            out.write(buf, buf.length + 1, 0);
-            fail("Expected Base64OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException");
-        } catch (IndexOutOfBoundsException ioobe) {
-            // Expected
-        }
-
-        try {
-            out.write(buf, buf.length - 1, 2);
-            fail("Expected Base64OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException");
-        } catch (IndexOutOfBoundsException ioobe) {
-            // Expected
-        }
-    }
-
-    /**
-     * Tests Base64OutputStream.write(null).
-     * 
-     * @throws Exception
-     *             for some failure scenarios.
-     */
-    public void testWriteToNullCoverage() throws Exception {
-        ByteArrayOutputStream bout = new ByteArrayOutputStream();
-        Base64OutputStream out = new Base64OutputStream(bout);
-        try {
-            out.write(null, 0, 0);
-            fail("Expcted Base64OutputStream.write(null) to throw a NullPointerException");
-        } catch (NullPointerException e) {
-            // Expected
-        }
-    }
-
-}
+     * Test the Base64OutputStream implementation against empty input.
+     * 
+     * @throws Exception
+     *             for some failure scenarios.
+     */

commit 4d67ff229be56b150180cd6652d118075d171e05
Author: Gary D. Gregory <ggregory@apache.org>
Date:   Tue Jul 21 04:00:52 2009

    Moved package private class CharsetEncodingNames to the main package under the name RequiredCharsetNames. "Charset" reflects the name used in the JRE instead of "encoding". Updated string literals for required charset names ("UTF-8", "US-ASCII", etc) with references to new class static constants. Also created the new class StringBytesUtils (need a better name?) to wrap calls to String#getBytes(String) and String#String(byte[],String) for required charset names, such that it is not required for call sites to catch or re-throw UnsupportedEncodingException since Java requires 6 charsets to be present.
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@796172 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
--- a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
@@ -1,312 +1,310 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package org.apache.commons.codec.binary;
 
 import java.io.ByteArrayOutputStream;
 import java.io.OutputStream;
 import java.util.Arrays;
 
 import junit.framework.TestCase;
 
 /**
  * @author Apache Software Foundation
  * @version $Id $
  * @since 1.4
  */
 public class Base64OutputStreamTest extends TestCase {
 
     private final static byte[] CRLF = {(byte) '\r', (byte) '\n'};
 
     private final static byte[] LF = {(byte) '\n'};
 
     private static final String STRING_FIXTURE = "Hello World";
 
-    private static final String UTF_8_NAME = "UTF-8";
-
     /**
      * Construct a new instance of this test case.
      * 
      * @param name
      *            Name of the test case
      */
     public Base64OutputStreamTest(String name) {
         super(name);
     }
 
     /**
      * Test the Base64OutputStream implementation against empty input.
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testBase64EmptyOutputStream() throws Exception {
         byte[] emptyEncoded = new byte[0];
         byte[] emptyDecoded = new byte[0];
         testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);
         testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);
     }
 
     /**
      * Test the Base64OutputStream implementation
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testBase64OutputStreamByChunk() throws Exception {
         // Hello World test.
-        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes(UTF_8_NAME);
-        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
+        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
         testByChunk(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
-        encoded = "AA==\r\n".getBytes(UTF_8_NAME);
+        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
         decoded = new byte[]{(byte) 0};
         testByChunk(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME);
+        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
-        encoded = singleLine.getBytes(UTF_8_NAME);
+        encoded = StringBytesUtils.getBytesUtf8(singleLine);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 0, LF);
 
         // test random data of sizes 0 thru 150
         for (int i = 0; i <= 150; i++) {
             byte[][] randomData = Base64TestData.randomData(i, false);
             encoded = randomData[1];
             decoded = randomData[0];
             testByChunk(encoded, decoded, 0, LF);
         }
     }
 
     /**
      * Test the Base64OutputStream implementation
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testBase64OutputStreamByteByByte() throws Exception {
         // Hello World test.
-        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes(UTF_8_NAME);
-        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
+        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
-        encoded = "AA==\r\n".getBytes("UTF-8");
+        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
         decoded = new byte[]{(byte) 0};
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME);
+        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
-        encoded = singleLine.getBytes(UTF_8_NAME);
+        encoded = StringBytesUtils.getBytesUtf8(singleLine);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 0, LF);
 
         // test random data of sizes 0 thru 150
         for (int i = 0; i <= 150; i++) {
             byte[][] randomData = Base64TestData.randomData(i, false);
             encoded = randomData[1];
             decoded = randomData[0];
             testByteByByte(encoded, decoded, 0, LF);
         }
     }
 
     /**
      * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
      * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64OutputStream wraps itself in encode and decode
      * mode over and over again.
      * 
      * @param encoded
      *            base64 encoded data
      * @param decoded
      *            the data from above, but decoded
      * @param chunkSize
      *            chunk size (line-length) of the base64 encoded data.
      * @param seperator
      *            Line separator in the base64 encoded data.
      * @throws Exception
      *             Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
 
         // Start with encode.
         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
         OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);
         out.write(decoded);
         out.close();
         byte[] output = byteOut.toByteArray();
         assertTrue("Streaming chunked base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         byteOut = new ByteArrayOutputStream();
         out = new Base64OutputStream(byteOut, false);
         out.write(encoded);
         out.close();
         output = byteOut.toByteArray();
         assertTrue("Streaming chunked base64 decode", Arrays.equals(output, decoded));
 
         // I always wanted to do this! (wrap encoder with decoder etc etc).
         byteOut = new ByteArrayOutputStream();
         out = byteOut;
         for (int i = 0; i < 10; i++) {
             out = new Base64OutputStream(out, false);
             out = new Base64OutputStream(out, true, chunkSize, seperator);
         }
         out.write(decoded);
         out.close();
         output = byteOut.toByteArray();
 
         assertTrue("Streaming chunked base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
     /**
      * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
      * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64OutputStream wraps itself in encode and decode
      * mode over and over again.
      * 
      * @param encoded
      *            base64 encoded data
      * @param decoded
      *            the data from above, but decoded
      * @param chunkSize
      *            chunk size (line-length) of the base64 encoded data.
      * @param seperator
      *            Line separator in the base64 encoded data.
      * @throws Exception
      *             Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
 
         // Start with encode.
         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
         OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);
         for (int i = 0; i < decoded.length; i++) {
             out.write(decoded[i]);
         }
         out.close();
         byte[] output = byteOut.toByteArray();
         assertTrue("Streaming byte-by-byte base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         byteOut = new ByteArrayOutputStream();
         out = new Base64OutputStream(byteOut, false);
         for (int i = 0; i < encoded.length; i++) {
             out.write(encoded[i]);
         }
         out.close();
         output = byteOut.toByteArray();
         assertTrue("Streaming byte-by-byte base64 decode", Arrays.equals(output, decoded));
 
         // Now let's try decode with tonnes of flushes.
         byteOut = new ByteArrayOutputStream();
         out = new Base64OutputStream(byteOut, false);
         for (int i = 0; i < encoded.length; i++) {
             out.write(encoded[i]);
             out.flush();
-        }                      
+        }
         out.close();
         output = byteOut.toByteArray();
-        assertTrue("Streaming byte-by-byte flush() base64 decode", Arrays.equals(output, decoded));        
+        assertTrue("Streaming byte-by-byte flush() base64 decode", Arrays.equals(output, decoded));
 
         // I always wanted to do this! (wrap encoder with decoder etc etc).
         byteOut = new ByteArrayOutputStream();
         out = byteOut;
         for (int i = 0; i < 10; i++) {
             out = new Base64OutputStream(out, false);
             out = new Base64OutputStream(out, true, chunkSize, seperator);
         }
         for (int i = 0; i < decoded.length; i++) {
             out.write(decoded[i]);
         }
         out.close();
         output = byteOut.toByteArray();
 
         assertTrue("Streaming byte-by-byte base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
     /**
      * Tests Base64OutputStream.write for expected IndexOutOfBoundsException conditions.
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testWriteOutOfBounds() throws Exception {
         byte[] buf = new byte[1024];
         ByteArrayOutputStream bout = new ByteArrayOutputStream();
         Base64OutputStream out = new Base64OutputStream(bout);
 
         try {
             out.write(buf, -1, 1);
             fail("Expected Base64OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException");
         } catch (IndexOutOfBoundsException ioobe) {
             // Expected
         }
 
         try {
             out.write(buf, 1, -1);
             fail("Expected Base64OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException");
         } catch (IndexOutOfBoundsException ioobe) {
             // Expected
         }
 
         try {
             out.write(buf, buf.length + 1, 0);
             fail("Expected Base64OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException");
         } catch (IndexOutOfBoundsException ioobe) {
             // Expected
         }
 
         try {
             out.write(buf, buf.length - 1, 2);
             fail("Expected Base64OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException");
         } catch (IndexOutOfBoundsException ioobe) {
             // Expected
-        }        
+        }
     }
 
     /**
      * Tests Base64OutputStream.write(null).
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testWriteToNullCoverage() throws Exception {
         ByteArrayOutputStream bout = new ByteArrayOutputStream();
         Base64OutputStream out = new Base64OutputStream(bout);
         try {
             out.write(null, 0, 0);
             fail("Expcted Base64OutputStream.write(null) to throw a NullPointerException");
         } catch (NullPointerException e) {
             // Expected
         }
     }
 
 }

commit 6a43ce7aa8fb6be26fd0559b189dce704a0a32f5
Author: Gary D. Gregory <ggregory@apache.org>
Date:   Fri Jul 17 17:10:36 2009

    [CODEC-78] Base64 classes: Improve Code Coverage.
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@795228 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
--- a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
@@ -1,283 +1,312 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package org.apache.commons.codec.binary;
 
 import java.io.ByteArrayOutputStream;
 import java.io.OutputStream;
 import java.util.Arrays;
 
 import junit.framework.TestCase;
 
 /**
  * @author Apache Software Foundation
  * @version $Id $
  * @since 1.4
  */
 public class Base64OutputStreamTest extends TestCase {
 
     private final static byte[] CRLF = {(byte) '\r', (byte) '\n'};
 
     private final static byte[] LF = {(byte) '\n'};
 
+    private static final String STRING_FIXTURE = "Hello World";
+
+    private static final String UTF_8_NAME = "UTF-8";
+
     /**
      * Construct a new instance of this test case.
      * 
      * @param name
      *            Name of the test case
      */
     public Base64OutputStreamTest(String name) {
         super(name);
     }
 
     /**
      * Test the Base64OutputStream implementation against empty input.
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testBase64EmptyOutputStream() throws Exception {
         byte[] emptyEncoded = new byte[0];
         byte[] emptyDecoded = new byte[0];
         testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);
         testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);
     }
 
     /**
      * Test the Base64OutputStream implementation
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testBase64OutputStreamByChunk() throws Exception {
         // Hello World test.
-        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
-        byte[] decoded = "Hello World".getBytes("UTF-8");
+        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes(UTF_8_NAME);
+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
         testByChunk(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
-        encoded = "AA==\r\n".getBytes("UTF-8");
+        encoded = "AA==\r\n".getBytes(UTF_8_NAME);
         decoded = new byte[]{(byte) 0};
         testByChunk(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = Base64TestData.ENCODED.getBytes("UTF-8");
+        encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
-        encoded = singleLine.getBytes("UTF-8");
+        encoded = singleLine.getBytes(UTF_8_NAME);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 0, LF);
 
         // test random data of sizes 0 thru 150
         for (int i = 0; i <= 150; i++) {
             byte[][] randomData = Base64TestData.randomData(i, false);
             encoded = randomData[1];
             decoded = randomData[0];
             testByChunk(encoded, decoded, 0, LF);
         }
     }
 
     /**
      * Test the Base64OutputStream implementation
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testBase64OutputStreamByteByByte() throws Exception {
         // Hello World test.
-        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
-        byte[] decoded = "Hello World".getBytes("UTF-8");
+        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes(UTF_8_NAME);
+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
         encoded = "AA==\r\n".getBytes("UTF-8");
         decoded = new byte[]{(byte) 0};
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = Base64TestData.ENCODED.getBytes("UTF-8");
+        encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
-        encoded = singleLine.getBytes("UTF-8");
+        encoded = singleLine.getBytes(UTF_8_NAME);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 0, LF);
 
         // test random data of sizes 0 thru 150
         for (int i = 0; i <= 150; i++) {
             byte[][] randomData = Base64TestData.randomData(i, false);
             encoded = randomData[1];
             decoded = randomData[0];
             testByteByByte(encoded, decoded, 0, LF);
         }
     }
 
     /**
      * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
      * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64OutputStream wraps itself in encode and decode
      * mode over and over again.
      * 
      * @param encoded
      *            base64 encoded data
      * @param decoded
      *            the data from above, but decoded
      * @param chunkSize
      *            chunk size (line-length) of the base64 encoded data.
      * @param seperator
      *            Line separator in the base64 encoded data.
      * @throws Exception
      *             Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
 
         // Start with encode.
         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
         OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);
         out.write(decoded);
         out.close();
         byte[] output = byteOut.toByteArray();
-        assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
+        assertTrue("Streaming chunked base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         byteOut = new ByteArrayOutputStream();
         out = new Base64OutputStream(byteOut, false);
         out.write(encoded);
         out.close();
         output = byteOut.toByteArray();
-        assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
+        assertTrue("Streaming chunked base64 decode", Arrays.equals(output, decoded));
 
         // I always wanted to do this! (wrap encoder with decoder etc etc).
         byteOut = new ByteArrayOutputStream();
         out = byteOut;
         for (int i = 0; i < 10; i++) {
             out = new Base64OutputStream(out, false);
             out = new Base64OutputStream(out, true, chunkSize, seperator);
         }
         out.write(decoded);
         out.close();
         output = byteOut.toByteArray();
 
-        assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
+        assertTrue("Streaming chunked base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
     /**
      * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
      * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64OutputStream wraps itself in encode and decode
      * mode over and over again.
      * 
      * @param encoded
      *            base64 encoded data
      * @param decoded
      *            the data from above, but decoded
      * @param chunkSize
      *            chunk size (line-length) of the base64 encoded data.
      * @param seperator
      *            Line separator in the base64 encoded data.
      * @throws Exception
      *             Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
 
         // Start with encode.
         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
         OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);
         for (int i = 0; i < decoded.length; i++) {
             out.write(decoded[i]);
         }
         out.close();
         byte[] output = byteOut.toByteArray();
-        assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
+        assertTrue("Streaming byte-by-byte base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         byteOut = new ByteArrayOutputStream();
         out = new Base64OutputStream(byteOut, false);
         for (int i = 0; i < encoded.length; i++) {
             out.write(encoded[i]);
         }
         out.close();
         output = byteOut.toByteArray();
-        assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
+        assertTrue("Streaming byte-by-byte base64 decode", Arrays.equals(output, decoded));
+
+        // Now let's try decode with tonnes of flushes.
+        byteOut = new ByteArrayOutputStream();
+        out = new Base64OutputStream(byteOut, false);
+        for (int i = 0; i < encoded.length; i++) {
+            out.write(encoded[i]);
+            out.flush();
+        }                      
+        out.close();
+        output = byteOut.toByteArray();
+        assertTrue("Streaming byte-by-byte flush() base64 decode", Arrays.equals(output, decoded));        
 
         // I always wanted to do this! (wrap encoder with decoder etc etc).
         byteOut = new ByteArrayOutputStream();
         out = byteOut;
         for (int i = 0; i < 10; i++) {
             out = new Base64OutputStream(out, false);
             out = new Base64OutputStream(out, true, chunkSize, seperator);
         }
         for (int i = 0; i < decoded.length; i++) {
             out.write(decoded[i]);
         }
         out.close();
         output = byteOut.toByteArray();
 
-        assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
+        assertTrue("Streaming byte-by-byte base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
     /**
      * Tests Base64OutputStream.write for expected IndexOutOfBoundsException conditions.
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testWriteOutOfBounds() throws Exception {
         byte[] buf = new byte[1024];
         ByteArrayOutputStream bout = new ByteArrayOutputStream();
         Base64OutputStream out = new Base64OutputStream(bout);
 
         try {
-            out.write(buf, -1, 0);
-            fail("Expected Base64OutputStream.write(buf, -1, 0) to throw a IndexOutOfBoundsException");
+            out.write(buf, -1, 1);
+            fail("Expected Base64OutputStream.write(buf, -1, 1) to throw a IndexOutOfBoundsException");
+        } catch (IndexOutOfBoundsException ioobe) {
+            // Expected
+        }
+
+        try {
+            out.write(buf, 1, -1);
+            fail("Expected Base64OutputStream.write(buf, 1, -1) to throw a IndexOutOfBoundsException");
         } catch (IndexOutOfBoundsException ioobe) {
             // Expected
         }
 
         try {
             out.write(buf, buf.length + 1, 0);
             fail("Expected Base64OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException");
         } catch (IndexOutOfBoundsException ioobe) {
             // Expected
         }
+
+        try {
+            out.write(buf, buf.length - 1, 2);
+            fail("Expected Base64OutputStream.write(buf, buf.length - 1, 2) to throw a IndexOutOfBoundsException");
+        } catch (IndexOutOfBoundsException ioobe) {
+            // Expected
+        }        
     }
 
     /**
      * Tests Base64OutputStream.write(null).
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testWriteToNullCoverage() throws Exception {
         ByteArrayOutputStream bout = new ByteArrayOutputStream();
         Base64OutputStream out = new Base64OutputStream(bout);
         try {
             out.write(null, 0, 0);
             fail("Expcted Base64OutputStream.write(null) to throw a NullPointerException");
         } catch (NullPointerException e) {
             // Expected
         }
     }
 
 }

commit 2f76d9d334ac7470d908ab59feab58249f6ea8ac
Author: Gary D. Gregory <ggregory@apache.org>
Date:   Thu Jul 16 00:01:17 2009

    [CODEC-78] Base64: Improve Code Coverage.
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@794515 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
--- a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
@@ -1,220 +1,283 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package org.apache.commons.codec.binary;
 
-
 import java.io.ByteArrayOutputStream;
 import java.io.OutputStream;
 import java.util.Arrays;
 
 import junit.framework.TestCase;
 
 /**
  * @author Apache Software Foundation
  * @version $Id $
+ * @since 1.4
  */
 public class Base64OutputStreamTest extends TestCase {
 
     private final static byte[] CRLF = {(byte) '\r', (byte) '\n'};
+
     private final static byte[] LF = {(byte) '\n'};
 
     /**
      * Construct a new instance of this test case.
-     *
-     * @param name Name of the test case
+     * 
+     * @param name
+     *            Name of the test case
      */
     public Base64OutputStreamTest(String name) {
         super(name);
     }
 
     /**
      * Test the Base64OutputStream implementation against empty input.
-     *
-     * @throws Exception for some failure scenarios.
+     * 
+     * @throws Exception
+     *             for some failure scenarios.
      */
     public void testBase64EmptyOutputStream() throws Exception {
         byte[] emptyEncoded = new byte[0];
         byte[] emptyDecoded = new byte[0];
         testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);
         testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);
-    }    
+    }
 
     /**
      * Test the Base64OutputStream implementation
-     *
-     * @throws Exception for some failure scenarios.
+     * 
+     * @throws Exception
+     *             for some failure scenarios.
      */
-    public void testBase64OutputStreamByteByByte() throws Exception {
+    public void testBase64OutputStreamByChunk() throws Exception {
         // Hello World test.
         byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
         byte[] decoded = "Hello World".getBytes("UTF-8");
-        testByteByByte(encoded, decoded, 76, CRLF);
+        testByChunk(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
         encoded = "AA==\r\n".getBytes("UTF-8");
         decoded = new byte[]{(byte) 0};
-        testByteByByte(encoded, decoded, 76, CRLF);
+        testByChunk(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
         encoded = Base64TestData.ENCODED.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
-        testByteByByte(encoded, decoded, 64, LF);
+        testByChunk(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
         encoded = singleLine.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
-        testByteByByte(encoded, decoded, 0, LF);
+        testByChunk(encoded, decoded, 0, LF);
+
+        // test random data of sizes 0 thru 150
+        for (int i = 0; i <= 150; i++) {
+            byte[][] randomData = Base64TestData.randomData(i, false);
+            encoded = randomData[1];
+            decoded = randomData[0];
+            testByChunk(encoded, decoded, 0, LF);
+        }
     }
 
     /**
      * Test the Base64OutputStream implementation
-     *
-     * @throws Exception for some failure scenarios.
+     * 
+     * @throws Exception
+     *             for some failure scenarios.
      */
-    public void testBase64OutputStreamByChunk() throws Exception {
+    public void testBase64OutputStreamByteByByte() throws Exception {
         // Hello World test.
         byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
         byte[] decoded = "Hello World".getBytes("UTF-8");
-        testByChunk(encoded, decoded, 76, CRLF);
+        testByteByByte(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
         encoded = "AA==\r\n".getBytes("UTF-8");
         decoded = new byte[]{(byte) 0};
-        testByChunk(encoded, decoded, 76, CRLF);
+        testByteByByte(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
         encoded = Base64TestData.ENCODED.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
-        testByChunk(encoded, decoded, 64, LF);
+        testByteByByte(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
         encoded = singleLine.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
-        testByChunk(encoded, decoded, 0, LF);
-    }
+        testByteByByte(encoded, decoded, 0, LF);
 
+        // test random data of sizes 0 thru 150
+        for (int i = 0; i <= 150; i++) {
+            byte[][] randomData = Base64TestData.randomData(i, false);
+            encoded = randomData[1];
+            decoded = randomData[0];
+            testByteByByte(encoded, decoded, 0, LF);
+        }
+    }
 
     /**
-     * Test method does three tests on the supplied data:
-     * 1. encoded ---[DECODE]--> decoded
-     * 2. decoded ---[ENCODE]--> encoded
-     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
+     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
-     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
-     * Base64OutputStream wraps itself in encode and decode mode
-     * over and over again.
-     *
-     * @param encoded   base64 encoded data
-     * @param decoded   the data from above, but decoded
-     * @param chunkSize chunk size (line-length) of the base64 encoded data.
-     * @param seperator Line separator in the base64 encoded data.
-     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
+     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64OutputStream wraps itself in encode and decode
+     * mode over and over again.
+     * 
+     * @param encoded
+     *            base64 encoded data
+     * @param decoded
+     *            the data from above, but decoded
+     * @param chunkSize
+     *            chunk size (line-length) of the base64 encoded data.
+     * @param seperator
+     *            Line separator in the base64 encoded data.
+     * @throws Exception
+     *             Usually signifies a bug in the Base64 commons-codec implementation.
      */
-    private void testByteByByte(
-            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
-    ) throws Exception {
+    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
 
         // Start with encode.
         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
         OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);
-        for (int i = 0; i < decoded.length; i++) {
-            out.write(decoded[i]);
-        }
+        out.write(decoded);
         out.close();
         byte[] output = byteOut.toByteArray();
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         byteOut = new ByteArrayOutputStream();
         out = new Base64OutputStream(byteOut, false);
-        for (int i = 0; i < encoded.length; i++) {
-            out.write(encoded[i]);
-        }
+        out.write(encoded);
         out.close();
         output = byteOut.toByteArray();
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
-        // I always wanted to do this!  (wrap encoder with decoder etc etc).
+        // I always wanted to do this! (wrap encoder with decoder etc etc).
         byteOut = new ByteArrayOutputStream();
         out = byteOut;
         for (int i = 0; i < 10; i++) {
             out = new Base64OutputStream(out, false);
             out = new Base64OutputStream(out, true, chunkSize, seperator);
         }
-        for (int i = 0; i < decoded.length; i++) {
-            out.write(decoded[i]);
-        }
+        out.write(decoded);
         out.close();
         output = byteOut.toByteArray();
 
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
     /**
-     * Test method does three tests on the supplied data:
-     * 1. encoded ---[DECODE]--> decoded
-     * 2. decoded ---[ENCODE]--> encoded
-     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
+     * Test method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
-     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
-     * Base64OutputStream wraps itself in encode and decode mode
-     * over and over again.
-     *
-     * @param encoded   base64 encoded data
-     * @param decoded   the data from above, but decoded
-     * @param chunkSize chunk size (line-length) of the base64 encoded data.
-     * @param seperator Line separator in the base64 encoded data.
-     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
+     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64OutputStream wraps itself in encode and decode
+     * mode over and over again.
+     * 
+     * @param encoded
+     *            base64 encoded data
+     * @param decoded
+     *            the data from above, but decoded
+     * @param chunkSize
+     *            chunk size (line-length) of the base64 encoded data.
+     * @param seperator
+     *            Line separator in the base64 encoded data.
+     * @throws Exception
+     *             Usually signifies a bug in the Base64 commons-codec implementation.
      */
-    private void testByChunk(
-            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
-    ) throws Exception {
+    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
 
         // Start with encode.
         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
         OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);
-        out.write(decoded);
+        for (int i = 0; i < decoded.length; i++) {
+            out.write(decoded[i]);
+        }
         out.close();
         byte[] output = byteOut.toByteArray();
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         byteOut = new ByteArrayOutputStream();
         out = new Base64OutputStream(byteOut, false);
-        out.write(encoded);
+        for (int i = 0; i < encoded.length; i++) {
+            out.write(encoded[i]);
+        }
         out.close();
         output = byteOut.toByteArray();
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
-        // I always wanted to do this!  (wrap encoder with decoder etc etc).
+        // I always wanted to do this! (wrap encoder with decoder etc etc).
         byteOut = new ByteArrayOutputStream();
         out = byteOut;
         for (int i = 0; i < 10; i++) {
             out = new Base64OutputStream(out, false);
             out = new Base64OutputStream(out, true, chunkSize, seperator);
         }
-        out.write(decoded);
+        for (int i = 0; i < decoded.length; i++) {
+            out.write(decoded[i]);
+        }
         out.close();
         output = byteOut.toByteArray();
 
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
+    /**
+     * Tests Base64OutputStream.write for expected IndexOutOfBoundsException conditions.
+     * 
+     * @throws Exception
+     *             for some failure scenarios.
+     */
+    public void testWriteOutOfBounds() throws Exception {
+        byte[] buf = new byte[1024];
+        ByteArrayOutputStream bout = new ByteArrayOutputStream();
+        Base64OutputStream out = new Base64OutputStream(bout);
+
+        try {
+            out.write(buf, -1, 0);
+            fail("Expected Base64OutputStream.write(buf, -1, 0) to throw a IndexOutOfBoundsException");
+        } catch (IndexOutOfBoundsException ioobe) {
+            // Expected
+        }
+
+        try {
+            out.write(buf, buf.length + 1, 0);
+            fail("Expected Base64OutputStream.write(buf, buf.length + 1, 0) to throw a IndexOutOfBoundsException");
+        } catch (IndexOutOfBoundsException ioobe) {
+            // Expected
+        }
+    }
+
+    /**
+     * Tests Base64OutputStream.write(null).
+     * 
+     * @throws Exception
+     *             for some failure scenarios.
+     */
+    public void testWriteToNullCoverage() throws Exception {
+        ByteArrayOutputStream bout = new ByteArrayOutputStream();
+        Base64OutputStream out = new Base64OutputStream(bout);
+        try {
+            out.write(null, 0, 0);
+            fail("Expcted Base64OutputStream.write(null) to throw a NullPointerException");
+        } catch (NullPointerException e) {
+            // Expected
+        }
+    }
+
 }

commit 4449af5be0d81e35daef251055eca4cbfffd1d5c
Author: Gary D. Gregory <ggregory@apache.org>
Date:   Mon Jul 13 18:43:37 2009

    [CODEC-77] Base64 bug with empty input (new byte[0])
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@793736 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
--- a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
@@ -1,220 +1,220 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package org.apache.commons.codec.binary;
 
 
-import junit.framework.TestCase;
-
 import java.io.ByteArrayOutputStream;
 import java.io.OutputStream;
 import java.util.Arrays;
 
+import junit.framework.TestCase;
+
 /**
  * @author Apache Software Foundation
  * @version $Id $
  */
 public class Base64OutputStreamTest extends TestCase {
 
     private final static byte[] CRLF = {(byte) '\r', (byte) '\n'};
     private final static byte[] LF = {(byte) '\n'};
 
     /**
      * Construct a new instance of this test case.
      *
      * @param name Name of the test case
      */
     public Base64OutputStreamTest(String name) {
         super(name);
     }
 
     /**
      * Test the Base64OutputStream implementation against empty input.
      *
      * @throws Exception for some failure scenarios.
      */
     public void testBase64EmptyOutputStream() throws Exception {
         byte[] emptyEncoded = new byte[0];
         byte[] emptyDecoded = new byte[0];
         testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);
         testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);
     }    
 
     /**
      * Test the Base64OutputStream implementation
      *
      * @throws Exception for some failure scenarios.
      */
     public void testBase64OutputStreamByteByByte() throws Exception {
         // Hello World test.
         byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
         byte[] decoded = "Hello World".getBytes("UTF-8");
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
         encoded = "AA==\r\n".getBytes("UTF-8");
         decoded = new byte[]{(byte) 0};
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
         encoded = Base64TestData.ENCODED.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
         encoded = singleLine.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 0, LF);
     }
 
     /**
      * Test the Base64OutputStream implementation
      *
      * @throws Exception for some failure scenarios.
      */
     public void testBase64OutputStreamByChunk() throws Exception {
         // Hello World test.
         byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
         byte[] decoded = "Hello World".getBytes("UTF-8");
         testByChunk(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
         encoded = "AA==\r\n".getBytes("UTF-8");
         decoded = new byte[]{(byte) 0};
         testByChunk(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
         encoded = Base64TestData.ENCODED.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
         encoded = singleLine.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 0, LF);
     }
 
 
     /**
      * Test method does three tests on the supplied data:
      * 1. encoded ---[DECODE]--> decoded
      * 2. decoded ---[ENCODE]--> encoded
      * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
      * Base64OutputStream wraps itself in encode and decode mode
      * over and over again.
      *
      * @param encoded   base64 encoded data
      * @param decoded   the data from above, but decoded
      * @param chunkSize chunk size (line-length) of the base64 encoded data.
      * @param seperator Line separator in the base64 encoded data.
      * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByteByByte(
             byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
     ) throws Exception {
 
         // Start with encode.
         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
         OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);
         for (int i = 0; i < decoded.length; i++) {
             out.write(decoded[i]);
         }
         out.close();
         byte[] output = byteOut.toByteArray();
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         byteOut = new ByteArrayOutputStream();
         out = new Base64OutputStream(byteOut, false);
         for (int i = 0; i < encoded.length; i++) {
             out.write(encoded[i]);
         }
         out.close();
         output = byteOut.toByteArray();
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
         // I always wanted to do this!  (wrap encoder with decoder etc etc).
         byteOut = new ByteArrayOutputStream();
         out = byteOut;
         for (int i = 0; i < 10; i++) {
             out = new Base64OutputStream(out, false);
             out = new Base64OutputStream(out, true, chunkSize, seperator);
         }
         for (int i = 0; i < decoded.length; i++) {
             out.write(decoded[i]);
         }
         out.close();
         output = byteOut.toByteArray();
 
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
     /**
      * Test method does three tests on the supplied data:
      * 1. encoded ---[DECODE]--> decoded
      * 2. decoded ---[ENCODE]--> encoded
      * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
      * Base64OutputStream wraps itself in encode and decode mode
      * over and over again.
      *
      * @param encoded   base64 encoded data
      * @param decoded   the data from above, but decoded
      * @param chunkSize chunk size (line-length) of the base64 encoded data.
      * @param seperator Line separator in the base64 encoded data.
      * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByChunk(
             byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
     ) throws Exception {
 
         // Start with encode.
         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
         OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);
         out.write(decoded);
         out.close();
         byte[] output = byteOut.toByteArray();
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         byteOut = new ByteArrayOutputStream();
         out = new Base64OutputStream(byteOut, false);
         out.write(encoded);
         out.close();
         output = byteOut.toByteArray();
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
         // I always wanted to do this!  (wrap encoder with decoder etc etc).
         byteOut = new ByteArrayOutputStream();
         out = byteOut;
         for (int i = 0; i < 10; i++) {
             out = new Base64OutputStream(out, false);
             out = new Base64OutputStream(out, true, chunkSize, seperator);
         }
         out.write(decoded);
         out.close();
         output = byteOut.toByteArray();
 
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
 }

commit b8c2d9d9dc9aab45f83cf49ac93cfa8546e4c08e
Author: Gary D. Gregory <ggregory@apache.org>
Date:   Mon Jul 13 18:33:28 2009

    [CODEC-77] Base64 bug with empty input (new byte[0])
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@793734 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
--- a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
@@ -1,208 +1,220 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package org.apache.commons.codec.binary;
 
 
 import junit.framework.TestCase;
 
 import java.io.ByteArrayOutputStream;
 import java.io.OutputStream;
 import java.util.Arrays;
 
 /**
  * @author Apache Software Foundation
  * @version $Id $
  */
 public class Base64OutputStreamTest extends TestCase {
 
     private final static byte[] CRLF = {(byte) '\r', (byte) '\n'};
     private final static byte[] LF = {(byte) '\n'};
 
     /**
      * Construct a new instance of this test case.
      *
      * @param name Name of the test case
      */
     public Base64OutputStreamTest(String name) {
         super(name);
     }
 
     /**
+     * Test the Base64OutputStream implementation against empty input.
+     *
+     * @throws Exception for some failure scenarios.
+     */
+    public void testBase64EmptyOutputStream() throws Exception {
+        byte[] emptyEncoded = new byte[0];
+        byte[] emptyDecoded = new byte[0];
+        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);
+        testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);
+    }    
+
+    /**
      * Test the Base64OutputStream implementation
      *
      * @throws Exception for some failure scenarios.
      */
-    public void testBase64InputStreamByteByByte() throws Exception {
+    public void testBase64OutputStreamByteByByte() throws Exception {
         // Hello World test.
         byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
         byte[] decoded = "Hello World".getBytes("UTF-8");
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
         encoded = "AA==\r\n".getBytes("UTF-8");
         decoded = new byte[]{(byte) 0};
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
         encoded = Base64TestData.ENCODED.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
         encoded = singleLine.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 0, LF);
     }
 
     /**
      * Test the Base64OutputStream implementation
      *
      * @throws Exception for some failure scenarios.
      */
-    public void testBase64InputStreamByChunk() throws Exception {
+    public void testBase64OutputStreamByChunk() throws Exception {
         // Hello World test.
         byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
         byte[] decoded = "Hello World".getBytes("UTF-8");
         testByChunk(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
         encoded = "AA==\r\n".getBytes("UTF-8");
         decoded = new byte[]{(byte) 0};
         testByChunk(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
         encoded = Base64TestData.ENCODED.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
         encoded = singleLine.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 0, LF);
     }
 
 
     /**
      * Test method does three tests on the supplied data:
      * 1. encoded ---[DECODE]--> decoded
      * 2. decoded ---[ENCODE]--> encoded
      * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
      * Base64OutputStream wraps itself in encode and decode mode
      * over and over again.
      *
      * @param encoded   base64 encoded data
      * @param decoded   the data from above, but decoded
      * @param chunkSize chunk size (line-length) of the base64 encoded data.
      * @param seperator Line separator in the base64 encoded data.
      * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByteByByte(
             byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
     ) throws Exception {
 
         // Start with encode.
         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
         OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);
         for (int i = 0; i < decoded.length; i++) {
             out.write(decoded[i]);
         }
         out.close();
         byte[] output = byteOut.toByteArray();
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         byteOut = new ByteArrayOutputStream();
         out = new Base64OutputStream(byteOut, false);
         for (int i = 0; i < encoded.length; i++) {
             out.write(encoded[i]);
         }
         out.close();
         output = byteOut.toByteArray();
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
         // I always wanted to do this!  (wrap encoder with decoder etc etc).
         byteOut = new ByteArrayOutputStream();
         out = byteOut;
         for (int i = 0; i < 10; i++) {
             out = new Base64OutputStream(out, false);
             out = new Base64OutputStream(out, true, chunkSize, seperator);
         }
         for (int i = 0; i < decoded.length; i++) {
             out.write(decoded[i]);
         }
         out.close();
         output = byteOut.toByteArray();
 
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
     /**
      * Test method does three tests on the supplied data:
      * 1. encoded ---[DECODE]--> decoded
      * 2. decoded ---[ENCODE]--> encoded
      * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
      * Base64OutputStream wraps itself in encode and decode mode
      * over and over again.
      *
      * @param encoded   base64 encoded data
      * @param decoded   the data from above, but decoded
      * @param chunkSize chunk size (line-length) of the base64 encoded data.
      * @param seperator Line separator in the base64 encoded data.
      * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByChunk(
             byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
     ) throws Exception {
 
         // Start with encode.
         ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
         OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);
         out.write(decoded);
         out.close();
         byte[] output = byteOut.toByteArray();
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         byteOut = new ByteArrayOutputStream();
         out = new Base64OutputStream(byteOut, false);
         out.write(encoded);
         out.close();
         output = byteOut.toByteArray();
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
         // I always wanted to do this!  (wrap encoder with decoder etc etc).
         byteOut = new ByteArrayOutputStream();
         out = byteOut;
         for (int i = 0; i < 10; i++) {
             out = new Base64OutputStream(out, false);
             out = new Base64OutputStream(out, true, chunkSize, seperator);
         }
         out.write(decoded);
         out.close();
         output = byteOut.toByteArray();
 
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
 }

commit e2df85024e2ab99645a788b4b2836ba1cfdb87f5
Author: Jochen Wiedmann <jochen@apache.org>
Date:   Wed Jun 18 15:16:03 2008

    PR: CODED-69
    Submitted-By: Julius Davies <juliusdavies@gmail.com>
    Added the Base64InputStream and the Base64OutputStream.
    
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@669256 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
--- /dev/null
+++ b/src/test/org/apache/commons/codec/binary/Base64OutputStreamTest.java
@@ -0,0 +1,208 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.binary;
+
+
+import junit.framework.TestCase;
+
+import java.io.ByteArrayOutputStream;
+import java.io.OutputStream;
+import java.util.Arrays;
+
+/**
+ * @author Apache Software Foundation
+ * @version $Id $
+ */
+public class Base64OutputStreamTest extends TestCase {
+
+    private final static byte[] CRLF = {(byte) '\r', (byte) '\n'};
+    private final static byte[] LF = {(byte) '\n'};
+
+    /**
+     * Construct a new instance of this test case.
+     *
+     * @param name Name of the test case
+     */
+    public Base64OutputStreamTest(String name) {
+        super(name);
+    }
+
+    /**
+     * Test the Base64OutputStream implementation
+     *
+     * @throws Exception for some failure scenarios.
+     */
+    public void testBase64InputStreamByteByByte() throws Exception {
+        // Hello World test.
+        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
+        byte[] decoded = "Hello World".getBytes("UTF-8");
+        testByteByByte(encoded, decoded, 76, CRLF);
+
+        // Single Byte test.
+        encoded = "AA==\r\n".getBytes("UTF-8");
+        decoded = new byte[]{(byte) 0};
+        testByteByByte(encoded, decoded, 76, CRLF);
+
+        // OpenSSL interop test.
+        encoded = Base64TestData.ENCODED.getBytes("UTF-8");
+        decoded = Base64TestData.DECODED;
+        testByteByByte(encoded, decoded, 64, LF);
+
+        // Single Line test.
+        String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
+        encoded = singleLine.getBytes("UTF-8");
+        decoded = Base64TestData.DECODED;
+        testByteByByte(encoded, decoded, 0, LF);
+    }
+
+    /**
+     * Test the Base64OutputStream implementation
+     *
+     * @throws Exception for some failure scenarios.
+     */
+    public void testBase64InputStreamByChunk() throws Exception {
+        // Hello World test.
+        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
+        byte[] decoded = "Hello World".getBytes("UTF-8");
+        testByChunk(encoded, decoded, 76, CRLF);
+
+        // Single Byte test.
+        encoded = "AA==\r\n".getBytes("UTF-8");
+        decoded = new byte[]{(byte) 0};
+        testByChunk(encoded, decoded, 76, CRLF);
+
+        // OpenSSL interop test.
+        encoded = Base64TestData.ENCODED.getBytes("UTF-8");
+        decoded = Base64TestData.DECODED;
+        testByChunk(encoded, decoded, 64, LF);
+
+        // Single Line test.
+        String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
+        encoded = singleLine.getBytes("UTF-8");
+        decoded = Base64TestData.DECODED;
+        testByChunk(encoded, decoded, 0, LF);
+    }
+
+
+    /**
+     * Test method does three tests on the supplied data:
+     * 1. encoded ---[DECODE]--> decoded
+     * 2. decoded ---[ENCODE]--> encoded
+     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
+     * <p/>
+     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
+     * Base64OutputStream wraps itself in encode and decode mode
+     * over and over again.
+     *
+     * @param encoded   base64 encoded data
+     * @param decoded   the data from above, but decoded
+     * @param chunkSize chunk size (line-length) of the base64 encoded data.
+     * @param seperator Line separator in the base64 encoded data.
+     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
+     */
+    private void testByteByByte(
+            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
+    ) throws Exception {
+
+        // Start with encode.
+        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
+        OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);
+        for (int i = 0; i < decoded.length; i++) {
+            out.write(decoded[i]);
+        }
+        out.close();
+        byte[] output = byteOut.toByteArray();
+        assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
+
+        // Now let's try decode.
+        byteOut = new ByteArrayOutputStream();
+        out = new Base64OutputStream(byteOut, false);
+        for (int i = 0; i < encoded.length; i++) {
+            out.write(encoded[i]);
+        }
+        out.close();
+        output = byteOut.toByteArray();
+        assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
+
+        // I always wanted to do this!  (wrap encoder with decoder etc etc).
+        byteOut = new ByteArrayOutputStream();
+        out = byteOut;
+        for (int i = 0; i < 10; i++) {
+            out = new Base64OutputStream(out, false);
+            out = new Base64OutputStream(out, true, chunkSize, seperator);
+        }
+        for (int i = 0; i < decoded.length; i++) {
+            out.write(decoded[i]);
+        }
+        out.close();
+        output = byteOut.toByteArray();
+
+        assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
+    }
+
+    /**
+     * Test method does three tests on the supplied data:
+     * 1. encoded ---[DECODE]--> decoded
+     * 2. decoded ---[ENCODE]--> encoded
+     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
+     * <p/>
+     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
+     * Base64OutputStream wraps itself in encode and decode mode
+     * over and over again.
+     *
+     * @param encoded   base64 encoded data
+     * @param decoded   the data from above, but decoded
+     * @param chunkSize chunk size (line-length) of the base64 encoded data.
+     * @param seperator Line separator in the base64 encoded data.
+     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
+     */
+    private void testByChunk(
+            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
+    ) throws Exception {
+
+        // Start with encode.
+        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
+        OutputStream out = new Base64OutputStream(byteOut, true, chunkSize, seperator);
+        out.write(decoded);
+        out.close();
+        byte[] output = byteOut.toByteArray();
+        assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
+
+        // Now let's try decode.
+        byteOut = new ByteArrayOutputStream();
+        out = new Base64OutputStream(byteOut, false);
+        out.write(encoded);
+        out.close();
+        output = byteOut.toByteArray();
+        assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
+
+        // I always wanted to do this!  (wrap encoder with decoder etc etc).
+        byteOut = new ByteArrayOutputStream();
+        out = byteOut;
+        for (int i = 0; i < 10; i++) {
+            out = new Base64OutputStream(out, false);
+            out = new Base64OutputStream(out, true, chunkSize, seperator);
+        }
+        out.write(decoded);
+        out.close();
+        output = byteOut.toByteArray();
+
+        assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
+    }
+
+}
