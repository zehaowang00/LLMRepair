commit 1fc451c79779bdbf788e8bfbec6dc031a47495d8
Author: Thomas Neidhart <tn@apache.org>
Date:   Mon Mar 19 14:33:42 2012

    [CODEC-130] Provided implementation of skip and available for BaseNCodecInputStream, added unit tests.
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@1302585 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java b/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java
--- a/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java
+++ b/src/test/java/org/apache/commons/codec/binary/Base64InputStreamTest.java
@@ -509,1 +549,6 @@
+    public void testSkipWrongArgument() throws Throwable {
+        InputStream ins = new ByteArrayInputStream(StringUtils.getBytesIso8859_1(ENCODED_B64));
+        Base64InputStream b64stream = new Base64InputStream(ins);
+        b64stream.skip(-10);
+    }
 }

commit d6ce22b75c7d06e24dc2994529dfa79a09016f04
Author: Niall Kegan Pemberton <niallp@apache.org>
Date:   Wed Jul 22 21:46:50 2009

    set svn:eol-style to native
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@796922 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
--- a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
@@ -1,332 +332,1 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.binary;
-
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
-import java.util.Arrays;
-
-import junit.framework.TestCase;
-
-/**
- * @author Apache Software Foundation
- * @version $Id $
- * @since 1.4
- */
-public class Base64InputStreamTest extends TestCase {
-
-    private final static byte[] CRLF = {(byte) '\r', (byte) '\n'};
-
-    private final static byte[] LF = {(byte) '\n'};
-
-    private static final String STRING_FIXTURE = "Hello World";
-
-    /**
-     * Construct a new instance of this test case.
-     * 
-     * @param name
-     *            Name of the test case
-     */
-    public Base64InputStreamTest(String name) {
-        super(name);
-    }
-
-    /**
-     * Tests the Base64InputStream implementation against empty input.
-     * 
-     * @throws Exception
-     *             for some failure scenarios.
-     */
-    public void testBase64EmptyInputStream() throws Exception {
-        byte[] emptyEncoded = new byte[0];
-        byte[] emptyDecoded = new byte[0];
-        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);
-        testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);
-    }
-
-    /**
-     * Tests the Base64InputStream implementation.
-     * 
-     * @throws Exception
-     *             for some failure scenarios.
-     */
-    public void testBase64InputStreamByChunk() throws Exception {
-        // Hello World test.
-        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
-        testByChunk(encoded, decoded, 76, CRLF);
-
-        // Single Byte test.
-        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
-        decoded = new byte[]{(byte) 0};
-        testByChunk(encoded, decoded, 76, CRLF);
-
-        // OpenSSL interop test.
-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);
-        decoded = Base64TestData.DECODED;
-        testByChunk(encoded, decoded, 64, LF);
-
-        // Single Line test.
-        String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
-        encoded = StringBytesUtils.getBytesUtf8(singleLine);
-        decoded = Base64TestData.DECODED;
-        testByChunk(encoded, decoded, 0, LF);
-
-        // test random data of sizes 0 thru 150
-        for (int i = 0; i <= 150; i++) {
-            byte[][] randomData = Base64TestData.randomData(i, false);
-            encoded = randomData[1];
-            decoded = randomData[0];
-            testByChunk(encoded, decoded, 0, LF);
-        }
-    }
-
-    /**
-     * Tests the Base64InputStream implementation.
-     * 
-     * @throws Exception
-     *             for some failure scenarios.
-     */
-    public void testBase64InputStreamByteByByte() throws Exception {
-        // Hello World test.
-        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
-        testByteByByte(encoded, decoded, 76, CRLF);
-
-        // Single Byte test.
-        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
-        decoded = new byte[]{(byte) 0};
-        testByteByByte(encoded, decoded, 76, CRLF);
-
-        // OpenSSL interop test.
-        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);
-        decoded = Base64TestData.DECODED;
-        testByteByByte(encoded, decoded, 64, LF);
-
-        // Single Line test.
-        String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
-        encoded = StringBytesUtils.getBytesUtf8(singleLine);
-        decoded = Base64TestData.DECODED;
-        testByteByByte(encoded, decoded, 0, LF);
-
-        // test random data of sizes 0 thru 150
-        for (int i = 0; i <= 150; i++) {
-            byte[][] randomData = Base64TestData.randomData(i, false);
-            encoded = randomData[1];
-            decoded = randomData[0];
-            testByteByByte(encoded, decoded, 0, LF);
-        }
-    }
-
-    /**
-     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
-     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
-     * <p/>
-     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64InputStream wraps itself in encode and decode mode
-     * over and over again.
-     * 
-     * @param encoded
-     *            base64 encoded data
-     * @param decoded
-     *            the data from above, but decoded
-     * @param chunkSize
-     *            chunk size (line-length) of the base64 encoded data.
-     * @param seperator
-     *            Line separator in the base64 encoded data.
-     * @throws Exception
-     *             Usually signifies a bug in the Base64 commons-codec implementation.
-     */
-    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
-
-        // Start with encode.
-        InputStream in = new ByteArrayInputStream(decoded);
-        in = new Base64InputStream(in, true, chunkSize, seperator);
-        byte[] output = Base64TestData.streamToBytes(in);
-
-        assertEquals("EOF", -1, in.read());
-        assertEquals("Still EOF", -1, in.read());
-        assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
-
-        // Now let's try decode.
-        in = new ByteArrayInputStream(encoded);
-        in = new Base64InputStream(in);
-        output = Base64TestData.streamToBytes(in);
-
-        assertEquals("EOF", -1, in.read());
-        assertEquals("Still EOF", -1, in.read());
-        assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
-
-        // I always wanted to do this! (wrap encoder with decoder etc etc).
-        in = new ByteArrayInputStream(decoded);
-        for (int i = 0; i < 10; i++) {
-            in = new Base64InputStream(in, true, chunkSize, seperator);
-            in = new Base64InputStream(in, false);
-        }
-        output = Base64TestData.streamToBytes(in);
-
-        assertEquals("EOF", -1, in.read());
-        assertEquals("Still EOF", -1, in.read());
-        assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
-    }
-
-    /**
-     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
-     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
-     * <p/>
-     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64InputStream wraps itself in encode and decode mode
-     * over and over again.
-     * 
-     * @param encoded
-     *            base64 encoded data
-     * @param decoded
-     *            the data from above, but decoded
-     * @param chunkSize
-     *            chunk size (line-length) of the base64 encoded data.
-     * @param seperator
-     *            Line separator in the base64 encoded data.
-     * @throws Exception
-     *             Usually signifies a bug in the Base64 commons-codec implementation.
-     */
-    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
-
-        // Start with encode.
-        InputStream in = new ByteArrayInputStream(decoded);
-        in = new Base64InputStream(in, true, chunkSize, seperator);
-        byte[] output = new byte[encoded.length];
-        for (int i = 0; i < output.length; i++) {
-            output[i] = (byte) in.read();
-        }
-
-        assertEquals("EOF", -1, in.read());
-        assertEquals("Still EOF", -1, in.read());
-        assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
-
-        // Now let's try decode.
-        in = new ByteArrayInputStream(encoded);
-        in = new Base64InputStream(in);
-        output = new byte[decoded.length];
-        for (int i = 0; i < output.length; i++) {
-            output[i] = (byte) in.read();
-        }
-
-        assertEquals("EOF", -1, in.read());
-        assertEquals("Still EOF", -1, in.read());
-        assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
-
-        // I always wanted to do this! (wrap encoder with decoder etc etc).
-        in = new ByteArrayInputStream(decoded);
-        for (int i = 0; i < 10; i++) {
-            in = new Base64InputStream(in, true, chunkSize, seperator);
-            in = new Base64InputStream(in, false);
-        }
-        output = new byte[decoded.length];
-        for (int i = 0; i < output.length; i++) {
-            output[i] = (byte) in.read();
-        }
-
-        assertEquals("EOF", -1, in.read());
-        assertEquals("Still EOF", -1, in.read());
-        assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
-    }
-
-    /**
-     * Tests markSupported.
-     * 
-     * @throws Exception
-     */
-    public void testMarkSupported() throws Exception {
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
-        // Always returns false for now.
-        assertFalse("Base64InputStream.markSupported() is false", in.markSupported());
-    }
-
-    /**
-     * Tests read returning 0
-     * 
-     * @throws Exception
-     */
-    public void testRead0() throws Exception {
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
-        byte[] buf = new byte[1024];
-        int bytesRead = 0;
-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
-        bytesRead = in.read(buf, 0, 0);
-        assertEquals("Base64InputStream.read(buf, 0, 0) returns 0", 0, bytesRead);
-    }
-
-    /**
-     * Tests read with null.
-     * 
-     * @throws Exception
-     *             for some failure scenarios.
-     */
-    public void testReadNull() throws Exception {
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
-        try {
-            in.read(null, 0, 0);
-            fail("Base64InputStream.read(null, 0, 0) to throw a NullPointerException");
-        } catch (NullPointerException e) {
-            // Expected
-        }
-    }
-
-    /**
-     * Tests read throwing IndexOutOfBoundsException
-     * 
-     * @throws Exception
-     */
-    public void testReadOutOfBounds() throws Exception {
-        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
-        byte[] buf = new byte[1024];
-        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
-        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
-
-        try {
-            in.read(buf, -1, 0);
-            fail("Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException");
-        } catch (IndexOutOfBoundsException e) {
-            // Expected
-        }
-
-        try {
-            in.read(buf, 0, -1);
-            fail("Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException");
-        } catch (IndexOutOfBoundsException e) {
-            // Expected
-        }
-
-        try {
-            in.read(buf, buf.length + 1, 0);
-            fail("Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException");
-        } catch (IndexOutOfBoundsException e) {
-            // Expected
-        }
-
-        try {
-            in.read(buf, buf.length - 1, 2);
-            fail("Base64InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException");
-        } catch (IndexOutOfBoundsException e) {
-            // Expected
-        }
-    }
-}
+}

commit 4d67ff229be56b150180cd6652d118075d171e05
Author: Gary D. Gregory <ggregory@apache.org>
Date:   Tue Jul 21 04:00:52 2009

    Moved package private class CharsetEncodingNames to the main package under the name RequiredCharsetNames. "Charset" reflects the name used in the JRE instead of "encoding". Updated string literals for required charset names ("UTF-8", "US-ASCII", etc) with references to new class static constants. Also created the new class StringBytesUtils (need a better name?) to wrap calls to String#getBytes(String) and String#String(byte[],String) for required charset names, such that it is not required for call sites to catch or re-throw UnsupportedEncodingException since Java requires 6 charsets to be present.
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@796172 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
--- a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
@@ -1,334 +1,332 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package org.apache.commons.codec.binary;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.util.Arrays;
 
 import junit.framework.TestCase;
 
 /**
  * @author Apache Software Foundation
  * @version $Id $
  * @since 1.4
  */
 public class Base64InputStreamTest extends TestCase {
 
     private final static byte[] CRLF = {(byte) '\r', (byte) '\n'};
 
     private final static byte[] LF = {(byte) '\n'};
 
     private static final String STRING_FIXTURE = "Hello World";
 
-    private static final String UTF_8_NAME = "UTF-8";
-
     /**
      * Construct a new instance of this test case.
      * 
      * @param name
      *            Name of the test case
      */
     public Base64InputStreamTest(String name) {
         super(name);
     }
 
     /**
      * Tests the Base64InputStream implementation against empty input.
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testBase64EmptyInputStream() throws Exception {
         byte[] emptyEncoded = new byte[0];
         byte[] emptyDecoded = new byte[0];
         testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);
         testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);
     }
 
     /**
      * Tests the Base64InputStream implementation.
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testBase64InputStreamByChunk() throws Exception {
         // Hello World test.
-        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes(UTF_8_NAME);
-        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
+        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
         testByChunk(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
-        encoded = "AA==\r\n".getBytes(UTF_8_NAME);
+        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
         decoded = new byte[]{(byte) 0};
         testByChunk(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME);
+        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
-        encoded = singleLine.getBytes(UTF_8_NAME);
+        encoded = StringBytesUtils.getBytesUtf8(singleLine);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 0, LF);
 
         // test random data of sizes 0 thru 150
         for (int i = 0; i <= 150; i++) {
             byte[][] randomData = Base64TestData.randomData(i, false);
             encoded = randomData[1];
             decoded = randomData[0];
             testByChunk(encoded, decoded, 0, LF);
         }
     }
 
     /**
      * Tests the Base64InputStream implementation.
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testBase64InputStreamByteByByte() throws Exception {
         // Hello World test.
-        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes(UTF_8_NAME);
-        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
+        byte[] encoded = StringBytesUtils.getBytesUtf8("SGVsbG8gV29ybGQ=\r\n");
+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
-        encoded = "AA==\r\n".getBytes(UTF_8_NAME);
+        encoded = StringBytesUtils.getBytesUtf8("AA==\r\n");
         decoded = new byte[]{(byte) 0};
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME);
+        encoded = StringBytesUtils.getBytesUtf8(Base64TestData.ENCODED);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
-        encoded = singleLine.getBytes(UTF_8_NAME);
+        encoded = StringBytesUtils.getBytesUtf8(singleLine);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 0, LF);
 
         // test random data of sizes 0 thru 150
         for (int i = 0; i <= 150; i++) {
             byte[][] randomData = Base64TestData.randomData(i, false);
             encoded = randomData[1];
             decoded = randomData[0];
             testByteByByte(encoded, decoded, 0, LF);
         }
     }
 
     /**
      * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
      * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64InputStream wraps itself in encode and decode mode
      * over and over again.
      * 
      * @param encoded
      *            base64 encoded data
      * @param decoded
      *            the data from above, but decoded
      * @param chunkSize
      *            chunk size (line-length) of the base64 encoded data.
      * @param seperator
      *            Line separator in the base64 encoded data.
      * @throws Exception
      *             Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
 
         // Start with encode.
         InputStream in = new ByteArrayInputStream(decoded);
         in = new Base64InputStream(in, true, chunkSize, seperator);
         byte[] output = Base64TestData.streamToBytes(in);
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         in = new ByteArrayInputStream(encoded);
         in = new Base64InputStream(in);
         output = Base64TestData.streamToBytes(in);
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
         // I always wanted to do this! (wrap encoder with decoder etc etc).
         in = new ByteArrayInputStream(decoded);
         for (int i = 0; i < 10; i++) {
             in = new Base64InputStream(in, true, chunkSize, seperator);
             in = new Base64InputStream(in, false);
         }
         output = Base64TestData.streamToBytes(in);
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
     /**
      * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
      * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64InputStream wraps itself in encode and decode mode
      * over and over again.
      * 
      * @param encoded
      *            base64 encoded data
      * @param decoded
      *            the data from above, but decoded
      * @param chunkSize
      *            chunk size (line-length) of the base64 encoded data.
      * @param seperator
      *            Line separator in the base64 encoded data.
      * @throws Exception
      *             Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
 
         // Start with encode.
         InputStream in = new ByteArrayInputStream(decoded);
         in = new Base64InputStream(in, true, chunkSize, seperator);
         byte[] output = new byte[encoded.length];
         for (int i = 0; i < output.length; i++) {
             output[i] = (byte) in.read();
         }
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         in = new ByteArrayInputStream(encoded);
         in = new Base64InputStream(in);
         output = new byte[decoded.length];
         for (int i = 0; i < output.length; i++) {
             output[i] = (byte) in.read();
         }
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
         // I always wanted to do this! (wrap encoder with decoder etc etc).
         in = new ByteArrayInputStream(decoded);
         for (int i = 0; i < 10; i++) {
             in = new Base64InputStream(in, true, chunkSize, seperator);
             in = new Base64InputStream(in, false);
         }
         output = new byte[decoded.length];
         for (int i = 0; i < output.length; i++) {
             output[i] = (byte) in.read();
         }
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
     /**
      * Tests markSupported.
      * 
      * @throws Exception
      */
     public void testMarkSupported() throws Exception {
-        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
         // Always returns false for now.
         assertFalse("Base64InputStream.markSupported() is false", in.markSupported());
     }
 
     /**
      * Tests read returning 0
      * 
      * @throws Exception
      */
     public void testRead0() throws Exception {
-        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
         byte[] buf = new byte[1024];
         int bytesRead = 0;
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
         bytesRead = in.read(buf, 0, 0);
         assertEquals("Base64InputStream.read(buf, 0, 0) returns 0", 0, bytesRead);
     }
 
     /**
      * Tests read with null.
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testReadNull() throws Exception {
-        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
         try {
             in.read(null, 0, 0);
             fail("Base64InputStream.read(null, 0, 0) to throw a NullPointerException");
         } catch (NullPointerException e) {
             // Expected
         }
     }
 
     /**
      * Tests read throwing IndexOutOfBoundsException
      * 
      * @throws Exception
      */
     public void testReadOutOfBounds() throws Exception {
-        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
+        byte[] decoded = StringBytesUtils.getBytesUtf8(STRING_FIXTURE);
         byte[] buf = new byte[1024];
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
 
         try {
             in.read(buf, -1, 0);
             fail("Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException");
         } catch (IndexOutOfBoundsException e) {
             // Expected
         }
 
         try {
             in.read(buf, 0, -1);
             fail("Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException");
         } catch (IndexOutOfBoundsException e) {
             // Expected
         }
 
         try {
             in.read(buf, buf.length + 1, 0);
             fail("Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException");
         } catch (IndexOutOfBoundsException e) {
             // Expected
         }
 
         try {
             in.read(buf, buf.length - 1, 2);
             fail("Base64InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException");
         } catch (IndexOutOfBoundsException e) {
             // Expected
-        }        
+        }
     }
 }

commit 6a43ce7aa8fb6be26fd0559b189dce704a0a32f5
Author: Gary D. Gregory <ggregory@apache.org>
Date:   Fri Jul 17 17:10:36 2009

    [CODEC-78] Base64 classes: Improve Code Coverage.
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@795228 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
--- a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
@@ -1,320 +1,334 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package org.apache.commons.codec.binary;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.util.Arrays;
 
 import junit.framework.TestCase;
 
 /**
  * @author Apache Software Foundation
  * @version $Id $
  * @since 1.4
  */
 public class Base64InputStreamTest extends TestCase {
 
     private final static byte[] CRLF = {(byte) '\r', (byte) '\n'};
 
     private final static byte[] LF = {(byte) '\n'};
 
     private static final String STRING_FIXTURE = "Hello World";
 
     private static final String UTF_8_NAME = "UTF-8";
 
     /**
      * Construct a new instance of this test case.
      * 
      * @param name
      *            Name of the test case
      */
     public Base64InputStreamTest(String name) {
         super(name);
     }
 
     /**
      * Tests the Base64InputStream implementation against empty input.
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testBase64EmptyInputStream() throws Exception {
         byte[] emptyEncoded = new byte[0];
         byte[] emptyDecoded = new byte[0];
         testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);
         testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);
     }
 
     /**
      * Tests the Base64InputStream implementation.
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testBase64InputStreamByChunk() throws Exception {
         // Hello World test.
         byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes(UTF_8_NAME);
         byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
         testByChunk(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
         encoded = "AA==\r\n".getBytes(UTF_8_NAME);
         decoded = new byte[]{(byte) 0};
         testByChunk(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
         encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
         encoded = singleLine.getBytes(UTF_8_NAME);
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 0, LF);
 
         // test random data of sizes 0 thru 150
         for (int i = 0; i <= 150; i++) {
             byte[][] randomData = Base64TestData.randomData(i, false);
             encoded = randomData[1];
             decoded = randomData[0];
             testByChunk(encoded, decoded, 0, LF);
         }
     }
 
     /**
      * Tests the Base64InputStream implementation.
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testBase64InputStreamByteByByte() throws Exception {
         // Hello World test.
         byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes(UTF_8_NAME);
         byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
         encoded = "AA==\r\n".getBytes(UTF_8_NAME);
         decoded = new byte[]{(byte) 0};
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
         encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
         encoded = singleLine.getBytes(UTF_8_NAME);
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 0, LF);
 
         // test random data of sizes 0 thru 150
         for (int i = 0; i <= 150; i++) {
             byte[][] randomData = Base64TestData.randomData(i, false);
             encoded = randomData[1];
             decoded = randomData[0];
             testByteByByte(encoded, decoded, 0, LF);
         }
     }
 
     /**
      * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
      * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64InputStream wraps itself in encode and decode mode
      * over and over again.
      * 
      * @param encoded
      *            base64 encoded data
      * @param decoded
      *            the data from above, but decoded
      * @param chunkSize
      *            chunk size (line-length) of the base64 encoded data.
      * @param seperator
      *            Line separator in the base64 encoded data.
      * @throws Exception
      *             Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
 
         // Start with encode.
         InputStream in = new ByteArrayInputStream(decoded);
         in = new Base64InputStream(in, true, chunkSize, seperator);
         byte[] output = Base64TestData.streamToBytes(in);
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         in = new ByteArrayInputStream(encoded);
         in = new Base64InputStream(in);
         output = Base64TestData.streamToBytes(in);
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
         // I always wanted to do this! (wrap encoder with decoder etc etc).
         in = new ByteArrayInputStream(decoded);
         for (int i = 0; i < 10; i++) {
             in = new Base64InputStream(in, true, chunkSize, seperator);
             in = new Base64InputStream(in, false);
         }
         output = Base64TestData.streamToBytes(in);
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
     /**
      * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
      * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64InputStream wraps itself in encode and decode mode
      * over and over again.
      * 
      * @param encoded
      *            base64 encoded data
      * @param decoded
      *            the data from above, but decoded
      * @param chunkSize
      *            chunk size (line-length) of the base64 encoded data.
      * @param seperator
      *            Line separator in the base64 encoded data.
      * @throws Exception
      *             Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
 
         // Start with encode.
         InputStream in = new ByteArrayInputStream(decoded);
         in = new Base64InputStream(in, true, chunkSize, seperator);
         byte[] output = new byte[encoded.length];
         for (int i = 0; i < output.length; i++) {
             output[i] = (byte) in.read();
         }
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         in = new ByteArrayInputStream(encoded);
         in = new Base64InputStream(in);
         output = new byte[decoded.length];
         for (int i = 0; i < output.length; i++) {
             output[i] = (byte) in.read();
         }
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
         // I always wanted to do this! (wrap encoder with decoder etc etc).
         in = new ByteArrayInputStream(decoded);
         for (int i = 0; i < 10; i++) {
             in = new Base64InputStream(in, true, chunkSize, seperator);
             in = new Base64InputStream(in, false);
         }
         output = new byte[decoded.length];
         for (int i = 0; i < output.length; i++) {
             output[i] = (byte) in.read();
         }
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
     /**
      * Tests markSupported.
      * 
      * @throws Exception
      */
     public void testMarkSupported() throws Exception {
         byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
         // Always returns false for now.
         assertFalse("Base64InputStream.markSupported() is false", in.markSupported());
     }
 
     /**
      * Tests read returning 0
      * 
      * @throws Exception
      */
     public void testRead0() throws Exception {
         byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
         byte[] buf = new byte[1024];
         int bytesRead = 0;
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
         bytesRead = in.read(buf, 0, 0);
         assertEquals("Base64InputStream.read(buf, 0, 0) returns 0", 0, bytesRead);
     }
 
     /**
      * Tests read with null.
      * 
      * @throws Exception
      *             for some failure scenarios.
      */
     public void testReadNull() throws Exception {
         byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
         try {
             in.read(null, 0, 0);
             fail("Base64InputStream.read(null, 0, 0) to throw a NullPointerException");
         } catch (NullPointerException e) {
             // Expected
         }
     }
 
     /**
      * Tests read throwing IndexOutOfBoundsException
      * 
      * @throws Exception
      */
     public void testReadOutOfBounds() throws Exception {
         byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
         byte[] buf = new byte[1024];
         ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
         Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
 
         try {
             in.read(buf, -1, 0);
             fail("Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException");
         } catch (IndexOutOfBoundsException e) {
             // Expected
         }
 
         try {
+            in.read(buf, 0, -1);
+            fail("Expected Base64InputStream.read(buf, 0, -1) to throw IndexOutOfBoundsException");
+        } catch (IndexOutOfBoundsException e) {
+            // Expected
+        }
+
+        try {
             in.read(buf, buf.length + 1, 0);
             fail("Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException");
         } catch (IndexOutOfBoundsException e) {
             // Expected
         }
+
+        try {
+            in.read(buf, buf.length - 1, 2);
+            fail("Base64InputStream.read(buf, buf.length - 1, 2) throws IndexOutOfBoundsException");
+        } catch (IndexOutOfBoundsException e) {
+            // Expected
+        }        
     }
 }

commit 2f76d9d334ac7470d908ab59feab58249f6ea8ac
Author: Gary D. Gregory <ggregory@apache.org>
Date:   Thu Jul 16 00:01:17 2009

    [CODEC-78] Base64: Improve Code Coverage.
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@794515 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
--- a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
@@ -1,224 +1,320 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package org.apache.commons.codec.binary;
 
-
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.util.Arrays;
 
 import junit.framework.TestCase;
 
 /**
  * @author Apache Software Foundation
  * @version $Id $
+ * @since 1.4
  */
 public class Base64InputStreamTest extends TestCase {
 
     private final static byte[] CRLF = {(byte) '\r', (byte) '\n'};
+
     private final static byte[] LF = {(byte) '\n'};
 
+    private static final String STRING_FIXTURE = "Hello World";
+
+    private static final String UTF_8_NAME = "UTF-8";
+
     /**
      * Construct a new instance of this test case.
-     *
-     * @param name Name of the test case
+     * 
+     * @param name
+     *            Name of the test case
      */
     public Base64InputStreamTest(String name) {
         super(name);
     }
 
     /**
-     * Test the Base64InputStream implementation against empty input.
-     *
-     * @throws Exception for some failure scenarios.
-     */    
+     * Tests the Base64InputStream implementation against empty input.
+     * 
+     * @throws Exception
+     *             for some failure scenarios.
+     */
     public void testBase64EmptyInputStream() throws Exception {
         byte[] emptyEncoded = new byte[0];
         byte[] emptyDecoded = new byte[0];
         testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);
         testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);
     }
 
     /**
-     * Test the Base64InputStream implementation.
-     *
-     * @throws Exception for some failure scenarios.
+     * Tests the Base64InputStream implementation.
+     * 
+     * @throws Exception
+     *             for some failure scenarios.
      */
-    public void testBase64InputStreamByteByByte() throws Exception {
+    public void testBase64InputStreamByChunk() throws Exception {
         // Hello World test.
-        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
-        byte[] decoded = "Hello World".getBytes("UTF-8");
-        testByteByByte(encoded, decoded, 76, CRLF);
+        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes(UTF_8_NAME);
+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
+        testByChunk(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
-        encoded = "AA==\r\n".getBytes("UTF-8");
+        encoded = "AA==\r\n".getBytes(UTF_8_NAME);
         decoded = new byte[]{(byte) 0};
-        testByteByByte(encoded, decoded, 76, CRLF);
+        testByChunk(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = Base64TestData.ENCODED.getBytes("UTF-8");
+        encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME);
         decoded = Base64TestData.DECODED;
-        testByteByByte(encoded, decoded, 64, LF);
+        testByChunk(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
-        encoded = singleLine.getBytes("UTF-8");
+        encoded = singleLine.getBytes(UTF_8_NAME);
         decoded = Base64TestData.DECODED;
-        testByteByByte(encoded, decoded, 0, LF);
+        testByChunk(encoded, decoded, 0, LF);
+
+        // test random data of sizes 0 thru 150
+        for (int i = 0; i <= 150; i++) {
+            byte[][] randomData = Base64TestData.randomData(i, false);
+            encoded = randomData[1];
+            decoded = randomData[0];
+            testByChunk(encoded, decoded, 0, LF);
+        }
     }
 
     /**
-     * Test the Base64InputStream implementation.
-     *
-     * @throws Exception for some failure scenarios.
+     * Tests the Base64InputStream implementation.
+     * 
+     * @throws Exception
+     *             for some failure scenarios.
      */
-    public void testBase64InputStreamByChunk() throws Exception {
+    public void testBase64InputStreamByteByByte() throws Exception {
         // Hello World test.
-        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
-        byte[] decoded = "Hello World".getBytes("UTF-8");
-        testByChunk(encoded, decoded, 76, CRLF);
+        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes(UTF_8_NAME);
+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
+        testByteByByte(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
-        encoded = "AA==\r\n".getBytes("UTF-8");
+        encoded = "AA==\r\n".getBytes(UTF_8_NAME);
         decoded = new byte[]{(byte) 0};
-        testByChunk(encoded, decoded, 76, CRLF);
+        testByteByByte(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
-        encoded = Base64TestData.ENCODED.getBytes("UTF-8");
+        encoded = Base64TestData.ENCODED.getBytes(UTF_8_NAME);
         decoded = Base64TestData.DECODED;
-        testByChunk(encoded, decoded, 64, LF);
+        testByteByByte(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
-        encoded = singleLine.getBytes("UTF-8");
+        encoded = singleLine.getBytes(UTF_8_NAME);
         decoded = Base64TestData.DECODED;
-        testByChunk(encoded, decoded, 0, LF);
-    }
+        testByteByByte(encoded, decoded, 0, LF);
 
+        // test random data of sizes 0 thru 150
+        for (int i = 0; i <= 150; i++) {
+            byte[][] randomData = Base64TestData.randomData(i, false);
+            encoded = randomData[1];
+            decoded = randomData[0];
+            testByteByByte(encoded, decoded, 0, LF);
+        }
+    }
 
     /**
-     * Test method does three tests on the supplied data:
-     * 1. encoded ---[DECODE]--> decoded
-     * 2. decoded ---[ENCODE]--> encoded
-     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
-     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
-     * Base64InputStream wraps itself in encode and decode mode
+     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64InputStream wraps itself in encode and decode mode
      * over and over again.
-     *
-     * @param encoded   base64 encoded data
-     * @param decoded   the data from above, but decoded
-     * @param chunkSize chunk size (line-length) of the base64 encoded data.
-     * @param seperator Line separator in the base64 encoded data.
-     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
+     * 
+     * @param encoded
+     *            base64 encoded data
+     * @param decoded
+     *            the data from above, but decoded
+     * @param chunkSize
+     *            chunk size (line-length) of the base64 encoded data.
+     * @param seperator
+     *            Line separator in the base64 encoded data.
+     * @throws Exception
+     *             Usually signifies a bug in the Base64 commons-codec implementation.
      */
-    private void testByteByByte(
-            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
-    ) throws Exception {
+    private void testByChunk(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
 
         // Start with encode.
         InputStream in = new ByteArrayInputStream(decoded);
         in = new Base64InputStream(in, true, chunkSize, seperator);
-        byte[] output = new byte[encoded.length];
-        for (int i = 0; i < output.length; i++) {
-            output[i] = (byte) in.read();
-        }
+        byte[] output = Base64TestData.streamToBytes(in);
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         in = new ByteArrayInputStream(encoded);
         in = new Base64InputStream(in);
-        output = new byte[decoded.length];
-        for (int i = 0; i < output.length; i++) {
-            output[i] = (byte) in.read();
-        }
+        output = Base64TestData.streamToBytes(in);
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
-        // I always wanted to do this!  (wrap encoder with decoder etc etc).
+        // I always wanted to do this! (wrap encoder with decoder etc etc).
         in = new ByteArrayInputStream(decoded);
         for (int i = 0; i < 10; i++) {
             in = new Base64InputStream(in, true, chunkSize, seperator);
             in = new Base64InputStream(in, false);
         }
-        output = new byte[decoded.length];
-        for (int i = 0; i < output.length; i++) {
-            output[i] = (byte) in.read();
-        }
+        output = Base64TestData.streamToBytes(in);
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
     /**
-     * Test method does three tests on the supplied data:
-     * 1. encoded ---[DECODE]--> decoded
-     * 2. decoded ---[ENCODE]--> encoded
-     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
+     * Tests method does three tests on the supplied data: 1. encoded ---[DECODE]--> decoded 2. decoded ---[ENCODE]-->
+     * encoded 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
-     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
-     * Base64InputStream wraps itself in encode and decode mode
+     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the Base64InputStream wraps itself in encode and decode mode
      * over and over again.
-     *
-     * @param encoded   base64 encoded data
-     * @param decoded   the data from above, but decoded
-     * @param chunkSize chunk size (line-length) of the base64 encoded data.
-     * @param seperator Line separator in the base64 encoded data.
-     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
+     * 
+     * @param encoded
+     *            base64 encoded data
+     * @param decoded
+     *            the data from above, but decoded
+     * @param chunkSize
+     *            chunk size (line-length) of the base64 encoded data.
+     * @param seperator
+     *            Line separator in the base64 encoded data.
+     * @throws Exception
+     *             Usually signifies a bug in the Base64 commons-codec implementation.
      */
-    private void testByChunk(
-            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
-    ) throws Exception {
+    private void testByteByByte(byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator) throws Exception {
 
         // Start with encode.
         InputStream in = new ByteArrayInputStream(decoded);
         in = new Base64InputStream(in, true, chunkSize, seperator);
-        byte[] output = Base64TestData.streamToBytes(in);
+        byte[] output = new byte[encoded.length];
+        for (int i = 0; i < output.length; i++) {
+            output[i] = (byte) in.read();
+        }
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         in = new ByteArrayInputStream(encoded);
         in = new Base64InputStream(in);
-        output = Base64TestData.streamToBytes(in);
+        output = new byte[decoded.length];
+        for (int i = 0; i < output.length; i++) {
+            output[i] = (byte) in.read();
+        }
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
-        // I always wanted to do this!  (wrap encoder with decoder etc etc).
+        // I always wanted to do this! (wrap encoder with decoder etc etc).
         in = new ByteArrayInputStream(decoded);
         for (int i = 0; i < 10; i++) {
             in = new Base64InputStream(in, true, chunkSize, seperator);
             in = new Base64InputStream(in, false);
         }
-        output = Base64TestData.streamToBytes(in);
+        output = new byte[decoded.length];
+        for (int i = 0; i < output.length; i++) {
+            output[i] = (byte) in.read();
+        }
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
+
+    /**
+     * Tests markSupported.
+     * 
+     * @throws Exception
+     */
+    public void testMarkSupported() throws Exception {
+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
+        // Always returns false for now.
+        assertFalse("Base64InputStream.markSupported() is false", in.markSupported());
+    }
+
+    /**
+     * Tests read returning 0
+     * 
+     * @throws Exception
+     */
+    public void testRead0() throws Exception {
+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
+        byte[] buf = new byte[1024];
+        int bytesRead = 0;
+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
+        bytesRead = in.read(buf, 0, 0);
+        assertEquals("Base64InputStream.read(buf, 0, 0) returns 0", 0, bytesRead);
+    }
+
+    /**
+     * Tests read with null.
+     * 
+     * @throws Exception
+     *             for some failure scenarios.
+     */
+    public void testReadNull() throws Exception {
+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
+        try {
+            in.read(null, 0, 0);
+            fail("Base64InputStream.read(null, 0, 0) to throw a NullPointerException");
+        } catch (NullPointerException e) {
+            // Expected
+        }
+    }
+
+    /**
+     * Tests read throwing IndexOutOfBoundsException
+     * 
+     * @throws Exception
+     */
+    public void testReadOutOfBounds() throws Exception {
+        byte[] decoded = STRING_FIXTURE.getBytes(UTF_8_NAME);
+        byte[] buf = new byte[1024];
+        ByteArrayInputStream bin = new ByteArrayInputStream(decoded);
+        Base64InputStream in = new Base64InputStream(bin, true, 4, new byte[]{0, 0, 0});
+
+        try {
+            in.read(buf, -1, 0);
+            fail("Expected Base64InputStream.read(buf, -1, 0) to throw IndexOutOfBoundsException");
+        } catch (IndexOutOfBoundsException e) {
+            // Expected
+        }
+
+        try {
+            in.read(buf, buf.length + 1, 0);
+            fail("Base64InputStream.read(buf, buf.length + 1, 0) throws IndexOutOfBoundsException");
+        } catch (IndexOutOfBoundsException e) {
+            // Expected
+        }
+    }
 }

commit 4449af5be0d81e35daef251055eca4cbfffd1d5c
Author: Gary D. Gregory <ggregory@apache.org>
Date:   Mon Jul 13 18:43:37 2009

    [CODEC-77] Base64 bug with empty input (new byte[0])
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@793736 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
--- a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
@@ -1,224 +1,224 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package org.apache.commons.codec.binary;
 
 
-import junit.framework.TestCase;
-
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.util.Arrays;
 
+import junit.framework.TestCase;
+
 /**
  * @author Apache Software Foundation
  * @version $Id $
  */
 public class Base64InputStreamTest extends TestCase {
 
     private final static byte[] CRLF = {(byte) '\r', (byte) '\n'};
     private final static byte[] LF = {(byte) '\n'};
 
     /**
      * Construct a new instance of this test case.
      *
      * @param name Name of the test case
      */
     public Base64InputStreamTest(String name) {
         super(name);
     }
 
     /**
      * Test the Base64InputStream implementation against empty input.
      *
      * @throws Exception for some failure scenarios.
      */    
     public void testBase64EmptyInputStream() throws Exception {
         byte[] emptyEncoded = new byte[0];
         byte[] emptyDecoded = new byte[0];
         testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);
         testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);
     }
 
     /**
      * Test the Base64InputStream implementation.
      *
      * @throws Exception for some failure scenarios.
      */
     public void testBase64InputStreamByteByByte() throws Exception {
         // Hello World test.
         byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
         byte[] decoded = "Hello World".getBytes("UTF-8");
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
         encoded = "AA==\r\n".getBytes("UTF-8");
         decoded = new byte[]{(byte) 0};
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
         encoded = Base64TestData.ENCODED.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
         encoded = singleLine.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 0, LF);
     }
 
     /**
      * Test the Base64InputStream implementation.
      *
      * @throws Exception for some failure scenarios.
      */
     public void testBase64InputStreamByChunk() throws Exception {
         // Hello World test.
         byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
         byte[] decoded = "Hello World".getBytes("UTF-8");
         testByChunk(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
         encoded = "AA==\r\n".getBytes("UTF-8");
         decoded = new byte[]{(byte) 0};
         testByChunk(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
         encoded = Base64TestData.ENCODED.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
         encoded = singleLine.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 0, LF);
     }
 
 
     /**
      * Test method does three tests on the supplied data:
      * 1. encoded ---[DECODE]--> decoded
      * 2. decoded ---[ENCODE]--> encoded
      * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
      * Base64InputStream wraps itself in encode and decode mode
      * over and over again.
      *
      * @param encoded   base64 encoded data
      * @param decoded   the data from above, but decoded
      * @param chunkSize chunk size (line-length) of the base64 encoded data.
      * @param seperator Line separator in the base64 encoded data.
      * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByteByByte(
             byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
     ) throws Exception {
 
         // Start with encode.
         InputStream in = new ByteArrayInputStream(decoded);
         in = new Base64InputStream(in, true, chunkSize, seperator);
         byte[] output = new byte[encoded.length];
         for (int i = 0; i < output.length; i++) {
             output[i] = (byte) in.read();
         }
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         in = new ByteArrayInputStream(encoded);
         in = new Base64InputStream(in);
         output = new byte[decoded.length];
         for (int i = 0; i < output.length; i++) {
             output[i] = (byte) in.read();
         }
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
         // I always wanted to do this!  (wrap encoder with decoder etc etc).
         in = new ByteArrayInputStream(decoded);
         for (int i = 0; i < 10; i++) {
             in = new Base64InputStream(in, true, chunkSize, seperator);
             in = new Base64InputStream(in, false);
         }
         output = new byte[decoded.length];
         for (int i = 0; i < output.length; i++) {
             output[i] = (byte) in.read();
         }
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
     /**
      * Test method does three tests on the supplied data:
      * 1. encoded ---[DECODE]--> decoded
      * 2. decoded ---[ENCODE]--> encoded
      * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
      * Base64InputStream wraps itself in encode and decode mode
      * over and over again.
      *
      * @param encoded   base64 encoded data
      * @param decoded   the data from above, but decoded
      * @param chunkSize chunk size (line-length) of the base64 encoded data.
      * @param seperator Line separator in the base64 encoded data.
      * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByChunk(
             byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
     ) throws Exception {
 
         // Start with encode.
         InputStream in = new ByteArrayInputStream(decoded);
         in = new Base64InputStream(in, true, chunkSize, seperator);
         byte[] output = Base64TestData.streamToBytes(in);
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         in = new ByteArrayInputStream(encoded);
         in = new Base64InputStream(in);
         output = Base64TestData.streamToBytes(in);
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
         // I always wanted to do this!  (wrap encoder with decoder etc etc).
         in = new ByteArrayInputStream(decoded);
         for (int i = 0; i < 10; i++) {
             in = new Base64InputStream(in, true, chunkSize, seperator);
             in = new Base64InputStream(in, false);
         }
         output = Base64TestData.streamToBytes(in);
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 }

commit b8c2d9d9dc9aab45f83cf49ac93cfa8546e4c08e
Author: Gary D. Gregory <ggregory@apache.org>
Date:   Mon Jul 13 18:33:28 2009

    [CODEC-77] Base64 bug with empty input (new byte[0])
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@793734 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
--- a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
@@ -1,212 +1,224 @@
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 package org.apache.commons.codec.binary;
 
 
 import junit.framework.TestCase;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.util.Arrays;
 
 /**
  * @author Apache Software Foundation
  * @version $Id $
  */
 public class Base64InputStreamTest extends TestCase {
 
     private final static byte[] CRLF = {(byte) '\r', (byte) '\n'};
     private final static byte[] LF = {(byte) '\n'};
 
     /**
      * Construct a new instance of this test case.
      *
      * @param name Name of the test case
      */
     public Base64InputStreamTest(String name) {
         super(name);
     }
 
     /**
+     * Test the Base64InputStream implementation against empty input.
+     *
+     * @throws Exception for some failure scenarios.
+     */    
+    public void testBase64EmptyInputStream() throws Exception {
+        byte[] emptyEncoded = new byte[0];
+        byte[] emptyDecoded = new byte[0];
+        testByteByByte(emptyEncoded, emptyDecoded, 76, CRLF);
+        testByChunk(emptyEncoded, emptyDecoded, 76, CRLF);
+    }
+
+    /**
      * Test the Base64InputStream implementation.
      *
      * @throws Exception for some failure scenarios.
      */
     public void testBase64InputStreamByteByByte() throws Exception {
         // Hello World test.
         byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
         byte[] decoded = "Hello World".getBytes("UTF-8");
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
         encoded = "AA==\r\n".getBytes("UTF-8");
         decoded = new byte[]{(byte) 0};
         testByteByByte(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
         encoded = Base64TestData.ENCODED.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
         encoded = singleLine.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByteByByte(encoded, decoded, 0, LF);
     }
 
     /**
      * Test the Base64InputStream implementation.
      *
      * @throws Exception for some failure scenarios.
      */
     public void testBase64InputStreamByChunk() throws Exception {
         // Hello World test.
         byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
         byte[] decoded = "Hello World".getBytes("UTF-8");
         testByChunk(encoded, decoded, 76, CRLF);
 
         // Single Byte test.
         encoded = "AA==\r\n".getBytes("UTF-8");
         decoded = new byte[]{(byte) 0};
         testByChunk(encoded, decoded, 76, CRLF);
 
         // OpenSSL interop test.
         encoded = Base64TestData.ENCODED.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 64, LF);
 
         // Single Line test.
         String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
         encoded = singleLine.getBytes("UTF-8");
         decoded = Base64TestData.DECODED;
         testByChunk(encoded, decoded, 0, LF);
     }
 
 
     /**
      * Test method does three tests on the supplied data:
      * 1. encoded ---[DECODE]--> decoded
      * 2. decoded ---[ENCODE]--> encoded
      * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
      * Base64InputStream wraps itself in encode and decode mode
      * over and over again.
      *
      * @param encoded   base64 encoded data
      * @param decoded   the data from above, but decoded
      * @param chunkSize chunk size (line-length) of the base64 encoded data.
      * @param seperator Line separator in the base64 encoded data.
      * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByteByByte(
             byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
     ) throws Exception {
 
         // Start with encode.
         InputStream in = new ByteArrayInputStream(decoded);
         in = new Base64InputStream(in, true, chunkSize, seperator);
         byte[] output = new byte[encoded.length];
         for (int i = 0; i < output.length; i++) {
             output[i] = (byte) in.read();
         }
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         in = new ByteArrayInputStream(encoded);
         in = new Base64InputStream(in);
         output = new byte[decoded.length];
         for (int i = 0; i < output.length; i++) {
             output[i] = (byte) in.read();
         }
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
         // I always wanted to do this!  (wrap encoder with decoder etc etc).
         in = new ByteArrayInputStream(decoded);
         for (int i = 0; i < 10; i++) {
             in = new Base64InputStream(in, true, chunkSize, seperator);
             in = new Base64InputStream(in, false);
         }
         output = new byte[decoded.length];
         for (int i = 0; i < output.length; i++) {
             output[i] = (byte) in.read();
         }
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 
     /**
      * Test method does three tests on the supplied data:
      * 1. encoded ---[DECODE]--> decoded
      * 2. decoded ---[ENCODE]--> encoded
      * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
      * <p/>
      * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
      * Base64InputStream wraps itself in encode and decode mode
      * over and over again.
      *
      * @param encoded   base64 encoded data
      * @param decoded   the data from above, but decoded
      * @param chunkSize chunk size (line-length) of the base64 encoded data.
      * @param seperator Line separator in the base64 encoded data.
      * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
      */
     private void testByChunk(
             byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
     ) throws Exception {
 
         // Start with encode.
         InputStream in = new ByteArrayInputStream(decoded);
         in = new Base64InputStream(in, true, chunkSize, seperator);
         byte[] output = Base64TestData.streamToBytes(in);
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
 
         // Now let's try decode.
         in = new ByteArrayInputStream(encoded);
         in = new Base64InputStream(in);
         output = Base64TestData.streamToBytes(in);
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
 
         // I always wanted to do this!  (wrap encoder with decoder etc etc).
         in = new ByteArrayInputStream(decoded);
         for (int i = 0; i < 10; i++) {
             in = new Base64InputStream(in, true, chunkSize, seperator);
             in = new Base64InputStream(in, false);
         }
         output = Base64TestData.streamToBytes(in);
 
         assertEquals("EOF", -1, in.read());
         assertEquals("Still EOF", -1, in.read());
         assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
     }
 }

commit e2df85024e2ab99645a788b4b2836ba1cfdb87f5
Author: Jochen Wiedmann <jochen@apache.org>
Date:   Wed Jun 18 15:16:03 2008

    PR: CODED-69
    Submitted-By: Julius Davies <juliusdavies@gmail.com>
    Added the Base64InputStream and the Base64OutputStream.
    
    
    git-svn-id: https://svn.apache.org/repos/asf/commons/proper/codec/trunk@669256 13f79535-47bb-0310-9956-ffa450edef68

diff --git a/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
--- /dev/null
+++ b/src/test/org/apache/commons/codec/binary/Base64InputStreamTest.java
@@ -0,0 +1,212 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.commons.codec.binary;
+
+
+import junit.framework.TestCase;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.util.Arrays;
+
+/**
+ * @author Apache Software Foundation
+ * @version $Id $
+ */
+public class Base64InputStreamTest extends TestCase {
+
+    private final static byte[] CRLF = {(byte) '\r', (byte) '\n'};
+    private final static byte[] LF = {(byte) '\n'};
+
+    /**
+     * Construct a new instance of this test case.
+     *
+     * @param name Name of the test case
+     */
+    public Base64InputStreamTest(String name) {
+        super(name);
+    }
+
+    /**
+     * Test the Base64InputStream implementation.
+     *
+     * @throws Exception for some failure scenarios.
+     */
+    public void testBase64InputStreamByteByByte() throws Exception {
+        // Hello World test.
+        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
+        byte[] decoded = "Hello World".getBytes("UTF-8");
+        testByteByByte(encoded, decoded, 76, CRLF);
+
+        // Single Byte test.
+        encoded = "AA==\r\n".getBytes("UTF-8");
+        decoded = new byte[]{(byte) 0};
+        testByteByByte(encoded, decoded, 76, CRLF);
+
+        // OpenSSL interop test.
+        encoded = Base64TestData.ENCODED.getBytes("UTF-8");
+        decoded = Base64TestData.DECODED;
+        testByteByByte(encoded, decoded, 64, LF);
+
+        // Single Line test.
+        String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
+        encoded = singleLine.getBytes("UTF-8");
+        decoded = Base64TestData.DECODED;
+        testByteByByte(encoded, decoded, 0, LF);
+    }
+
+    /**
+     * Test the Base64InputStream implementation.
+     *
+     * @throws Exception for some failure scenarios.
+     */
+    public void testBase64InputStreamByChunk() throws Exception {
+        // Hello World test.
+        byte[] encoded = "SGVsbG8gV29ybGQ=\r\n".getBytes("UTF-8");
+        byte[] decoded = "Hello World".getBytes("UTF-8");
+        testByChunk(encoded, decoded, 76, CRLF);
+
+        // Single Byte test.
+        encoded = "AA==\r\n".getBytes("UTF-8");
+        decoded = new byte[]{(byte) 0};
+        testByChunk(encoded, decoded, 76, CRLF);
+
+        // OpenSSL interop test.
+        encoded = Base64TestData.ENCODED.getBytes("UTF-8");
+        decoded = Base64TestData.DECODED;
+        testByChunk(encoded, decoded, 64, LF);
+
+        // Single Line test.
+        String singleLine = Base64TestData.ENCODED.replaceAll("\n", "");
+        encoded = singleLine.getBytes("UTF-8");
+        decoded = Base64TestData.DECODED;
+        testByChunk(encoded, decoded, 0, LF);
+    }
+
+
+    /**
+     * Test method does three tests on the supplied data:
+     * 1. encoded ---[DECODE]--> decoded
+     * 2. decoded ---[ENCODE]--> encoded
+     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
+     * <p/>
+     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
+     * Base64InputStream wraps itself in encode and decode mode
+     * over and over again.
+     *
+     * @param encoded   base64 encoded data
+     * @param decoded   the data from above, but decoded
+     * @param chunkSize chunk size (line-length) of the base64 encoded data.
+     * @param seperator Line separator in the base64 encoded data.
+     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
+     */
+    private void testByteByByte(
+            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
+    ) throws Exception {
+
+        // Start with encode.
+        InputStream in = new ByteArrayInputStream(decoded);
+        in = new Base64InputStream(in, true, chunkSize, seperator);
+        byte[] output = new byte[encoded.length];
+        for (int i = 0; i < output.length; i++) {
+            output[i] = (byte) in.read();
+        }
+
+        assertEquals("EOF", -1, in.read());
+        assertEquals("Still EOF", -1, in.read());
+        assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
+
+        // Now let's try decode.
+        in = new ByteArrayInputStream(encoded);
+        in = new Base64InputStream(in);
+        output = new byte[decoded.length];
+        for (int i = 0; i < output.length; i++) {
+            output[i] = (byte) in.read();
+        }
+
+        assertEquals("EOF", -1, in.read());
+        assertEquals("Still EOF", -1, in.read());
+        assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
+
+        // I always wanted to do this!  (wrap encoder with decoder etc etc).
+        in = new ByteArrayInputStream(decoded);
+        for (int i = 0; i < 10; i++) {
+            in = new Base64InputStream(in, true, chunkSize, seperator);
+            in = new Base64InputStream(in, false);
+        }
+        output = new byte[decoded.length];
+        for (int i = 0; i < output.length; i++) {
+            output[i] = (byte) in.read();
+        }
+
+        assertEquals("EOF", -1, in.read());
+        assertEquals("Still EOF", -1, in.read());
+        assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
+    }
+
+    /**
+     * Test method does three tests on the supplied data:
+     * 1. encoded ---[DECODE]--> decoded
+     * 2. decoded ---[ENCODE]--> encoded
+     * 3. decoded ---[WRAP-WRAP-WRAP-etc...] --> decoded
+     * <p/>
+     * By "[WRAP-WRAP-WRAP-etc...]" we mean situation where the
+     * Base64InputStream wraps itself in encode and decode mode
+     * over and over again.
+     *
+     * @param encoded   base64 encoded data
+     * @param decoded   the data from above, but decoded
+     * @param chunkSize chunk size (line-length) of the base64 encoded data.
+     * @param seperator Line separator in the base64 encoded data.
+     * @throws Exception Usually signifies a bug in the Base64 commons-codec implementation.
+     */
+    private void testByChunk(
+            byte[] encoded, byte[] decoded, int chunkSize, byte[] seperator
+    ) throws Exception {
+
+        // Start with encode.
+        InputStream in = new ByteArrayInputStream(decoded);
+        in = new Base64InputStream(in, true, chunkSize, seperator);
+        byte[] output = Base64TestData.streamToBytes(in);
+
+        assertEquals("EOF", -1, in.read());
+        assertEquals("Still EOF", -1, in.read());
+        assertTrue("Streaming base64 encode", Arrays.equals(output, encoded));
+
+        // Now let's try decode.
+        in = new ByteArrayInputStream(encoded);
+        in = new Base64InputStream(in);
+        output = Base64TestData.streamToBytes(in);
+
+        assertEquals("EOF", -1, in.read());
+        assertEquals("Still EOF", -1, in.read());
+        assertTrue("Streaming base64 decode", Arrays.equals(output, decoded));
+
+        // I always wanted to do this!  (wrap encoder with decoder etc etc).
+        in = new ByteArrayInputStream(decoded);
+        for (int i = 0; i < 10; i++) {
+            in = new Base64InputStream(in, true, chunkSize, seperator);
+            in = new Base64InputStream(in, false);
+        }
+        output = Base64TestData.streamToBytes(in);
+
+        assertEquals("EOF", -1, in.read());
+        assertEquals("Still EOF", -1, in.read());
+        assertTrue("Streaming base64 wrap-wrap-wrap!", Arrays.equals(output, decoded));
+    }
+}
